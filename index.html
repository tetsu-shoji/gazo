
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>差分検出（基準切替・カメラ撮影・YOLOv8＋OpenCV）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{ --bg:#0b132b; --panel:#1c2541; --text:#eaeaea; --accent:#5bc0be; }
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,"Segoe UI",sans-serif;}
    header{padding:14px 18px;background:var(--panel);border-bottom:1px solid #2f3b66;}
    header h1{margin:0;font-size:18px}
    main{padding:16px;display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .card{background:var(--panel);border:1px solid #2f3b66;border-radius:10px;padding:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label.btn{background:#3a506b;color:#d6eaff;padding:10px 12px;border-radius:8px;cursor:pointer}
    input[type=file]{display:none}
    canvas, img, video{max-width:100%;height:auto;border-radius:6px;border:1px solid #2f3b66;background:#000}
    img{display:block}
    video{display:none}
    .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px}
    .control{background:#162447;border:1px solid #2f3b66;border-radius:8px;padding:8px}
    .control label{display:block;font-size:12px;margin-bottom:6px;opacity:.85}
    .btn{background:var(--accent);color:#012a36;border:none;border-radius:8px;padding:10px 12px;font-weight:700;cursor:pointer}
    .btn.secondary{background:#3a506b;color:#d6eaff}
    .small{font-size:12px;opacity:.8}
    @media (max-width:900px){ main{grid-template-columns:1fr} }
    .toggle{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .legend{font-size:12px;opacity:.8;margin-top:6px}
  </style>
  <!-- OpenCV.js 初期化通知 -->
  <script>
    window.__cvReady = false;
    window.Module = { onRuntimeInitialized(){ window.__cvReady = true; console.log('OpenCV.js ready'); } };
  </script>
</head>
<body>
<header><h1>差分検出（基準切替・カメラ撮影・YOLOv8＋OpenCV）</h1></header>

<main>
  <!-- 左：入力 -->
  <section class="card">
    <h2 style="margin:0 0 8px">入力画像／カメラ撮影</h2>
    <div class="row">
      <label class="btn">画像Aを選択<input id="fileA" type="file" accept="image/*" /></label>
      <label class="btn">画像Bを選択<input id="fileB" type="file" accept="image/*" /></label>
      <button id="btnDetect" class="btn">差分を検出</button>
      <button id="btnSaveJpg" class="btn secondary" disabled>JPEGで保存</button>
    </div>

    <!-- カメラ操作 -->
    <div class="row">
      <button id="btnCamStart" class="btn secondary">カメラ起動</button>
      <button id="btnCamShotA" class="btn secondary" disabled>撮影Aに取り込み</button>
      <button id="btnCamShotB" class="btn secondary" disabled>撮影Bに取り込み</button>
      <button id="btnCamStop"  class="btn secondary" disabled>カメラ停止</button>
    </div>
    <video id="videoPreview" playsinline></video>

    <!-- 基準・表現・補正 -->
    <div class="toggle" style="margin-top:8px">
      <span>基準画像：</span>
      <label><input type="radio" name="base" id="baseA" value="A" checked> A（Bに追加を検出）</label>
      <label><input type="radio" name="base" id="baseB" value="B"> B（Aに追加を検出）</label>
      <span style="margin-left:12px">表現：</span>
      <label><input type="radio" name="render" id="modeBoxes" value="boxes" checked> 枠（少数）</label>
      <label><input type="radio" name="render" id="modeHeat" value="heat"> ヒートマップ</label>
      <label style="margin-left:12px"><input type="checkbox" id="chkAlign"> 自動位置補正（試験）</label>
    </div>
    <p class="legend">
      ・A基準：<span style="color:#80a0ff">青枠</span>／ヒートは赤系の濃淡。B基準：<span style="color:#ffa040">橙枠</span>／ヒートは赤系の濃淡。<br>
      ・位置補正ONで、撮影時のわずかなズレを平行移動＋回転・スケール（AFFINE）で補正（未サポート環境では自動でフォールバック）。
    </p>

    <!-- しきい値群（おすすめデフォルト値済み） -->
    <div class="controls">
      <div class="control"><label>YOLO 信頼度しきい値 <span id="confVal">0.35</span></label>
        <input id="confThr" type="range" min="0.10" max="0.90" step="0.05" value="0.35">
      </div>
      <div class="control"><label>YOLO NMS IoU <span id="nmsVal">0.45</span></label>
        <input id="nmsThr" type="range" min="0.20" max="0.90" step="0.05" value="0.45">
      </div>
      <div class="control"><label>差分IoU（位置一致判定） <span id="iouVal">0.45</span></label>
        <input id="iouThr" type="range" min="0.20" max="0.90" step="0.05" value="0.45">
      </div>
      <div class="control"><label>サイズ差（面積相対差） <span id="sizeVal">0.50</span></label>
        <input id="sizeThr" type="range" min="0.10" max="0.90" step="0.05" value="0.50">
      </div>
      <div class="control"><label>OpenCV差分しきい値 <span id="cvThrVal">0</span></label>
        <!-- 0 で Otsu 自動閾を使用 -->
        <input id="cvThr" type="range" min="0" max="80" step="2" value="0">
      </div>
      <div class="control"><label>最小差分面積（%） <span id="minAreaVal">0.10</span></label>
        <input id="minArea" type="range" min="0.02" max="0.50" step="0.02" value="0.10">
      </div>
      <div class="control"><label>枠数の上限（Top‑K） <span id="topKVal">5</span></label>
        <input id="topK" type="range" min="1" max="12" step="1" value="5">
      </div>
      <div class="control"><label>最大表示幅（px） <span id="maxWVal">1024</span></label>
        <input id="maxW" type="range" min="640" max="1920" step="64" value="1024">
      </div>
      <div class="control"><label>大物体マスク閾（%） <span id="maskPctVal">2.0</span></label>
        <input id="maskPct" type="range" min="0.0" max="5.0" step="0.2" value="2.0">
      </div>
    </div>

    <p class="small">※ HEIC/HEIFはブラウザで表示できない場合があります。JPEG/PNGでお試しください。</p>
    <div class="row">
      <figure style="flex:1"><figcaption>画像Aプレビュー</figcaption><img id="imgA" alt=""></figure>
      <figure style="flex:1"><figcaption>画像Bプレビュー</figcaption><img id="imgB" alt=""></figure>
    </div>
  </section>

  <!-- 右：結果 -->
  <section class="card">
    <h2 style="margin:0 0 8px">結果（差分強調表示）</h2>
    <canvas id="canvas" width="1024" height="768"></canvas>
    <p class="small">下地は<strong>基準画像</strong>。枠は少数化（NMS＋面積しきい値＋Top‑K）、ヒートは差分領域の濃淡で強調、OpenCVは自動閾（Otsu）を推奨します。</p>
  </section>
</main>

<!-- ✅ 依存ライブラリ（CDN） -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* === UI参照 === */
const els = {
  fileA: document.getElementById('fileA'),
  fileB: document.getElementById('fileB'),
  imgA: document.getElementById('imgA'),
  imgB: document.getElementById('imgB'),
  canvas: document.getElementById('canvas'),
  btnDetect: document.getElementById('btnDetect'),
  btnSaveJpg: document.getElementById('btnSaveJpg'),
  baseA: document.getElementById('baseA'),
  baseB: document.getElementById('baseB'),
  modeBoxes: document.getElementById('modeBoxes'),
  modeHeat:  document.getElementById('modeHeat'),
  chkAlign:  document.getElementById('chkAlign'),
  confThr: document.getElementById('confThr'),
  nmsThr: document.getElementById('nmsThr'),
  iouThr: document.getElementById('iouThr'),
  sizeThr: document.getElementById('sizeThr'),
  cvThr: document.getElementById('cvThr'),
  minArea: document.getElementById('minArea'),
  topK: document.getElementById('topK'),
  maxW: document.getElementById('maxW'),
  maskPct: document.getElementById('maskPct'),
  confVal: document.getElementById('confVal'),
  nmsVal: document.getElementById('nmsVal'),
  iouVal: document.getElementById('iouVal'),
  sizeVal: document.getElementById('sizeVal'),
  cvThrVal: document.getElementById('cvThrVal'),
  minAreaVal: document.getElementById('minAreaVal'),
  topKVal: document.getElementById('topKVal'),
  maxWVal: document.getElementById('maxWVal'),
  maskPctVal: document.getElementById('maskPctVal'),
  btnCamStart: document.getElementById('btnCamStart'),
  btnCamShotA: document.getElementById('btnCamShotA'),
  btnCamShotB: document.getElementById('btnCamShotB'),
  btnCamStop:  document.getElementById('btnCamStop'),
  video: document.getElementById('videoPreview'),
};
let aReady=false, bReady=false;

/* === 画像読み込み（createObjectURL／HEIC検知） === */
els.fileA.addEventListener('change', e => loadViaObjectURL(e.target.files?.[0], els.imgA, () => aReady=true));
els.fileB.addEventListener('change', e => loadViaObjectURL(e.target.files?.[0], els.imgB, () => bReady=true));
function loadViaObjectURL(file, imgEl, onOk){
  if(!file){ alert('ファイルが選択されていません'); return; }
  const mime = (file.type||'').toLowerCase();
  if(!mime.startsWith('image/')){ alert('画像ファイルを選択してください（JPEG/PNG推奨）'); return; }
  if(mime.includes('heic') || mime.includes('heif')){
    alert('HEIC/HEIFは表示できない場合があります。JPEG/PNGでお試しください。'); return;
  }
  const url = URL.createObjectURL(file);
  imgEl.onload = ()=>{ URL.revokeObjectURL(url); onOk&&onOk(); };
  imgEl.onerror = ()=>{ URL.revokeObjectURL(url); alert('画像の読み込みに失敗しました。'); };
  imgEl.src = url;
}

/* === しきい値表示 === */
function updateVals(){
  els.confVal.textContent = parseFloat(els.confThr.value).toFixed(2);
  els.nmsVal.textContent  = parseFloat(els.nmsThr.value).toFixed(2);
  els.iouVal.textContent  = parseFloat(els.iouThr.value).toFixed(2);
  els.sizeVal.textContent = parseFloat(els.sizeThr.value).toFixed(2);
  els.cvThrVal.textContent= parseInt(els.cvThr.value,10);
  els.minAreaVal.textContent= parseFloat(els.minArea.value).toFixed(2);
  els.topKVal.textContent    = parseInt(els.topK.value,10);
  els.maxWVal.textContent    = parseInt(els.maxW.value,10);
  els.maskPctVal.textContent = parseFloat(els.maskPct.value).toFixed(1);
}
['confThr','nmsThr','iouThr','sizeThr','cvThr','minArea','topK','maxW','maskPct']
  .forEach(id=>els[id].addEventListener('input',updateVals));
updateVals();

/* === カメラ起動／撮影 === */
let camStream=null;
els.btnCamStart.addEventListener('click', async ()=>{
  try{
    camStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
    els.video.srcObject = camStream; els.video.style.display='block'; await els.video.play();
    els.btnCamShotA.disabled=false; els.btnCamShotB.disabled=false; els.btnCamStop.disabled=false;
  }catch(e){ alert('カメラ起動に失敗しました：'+e.message); }
});
els.btnCamStop.addEventListener('click', ()=>{
  try{ camStream?.getTracks()?.forEach(t=>t.stop()); }catch(_){}
  els.video.srcObject=null; els.video.style.display='none';
  els.btnCamShotA.disabled=true; els.btnCamShotB.disabled=true; els.btnCamStop.disabled=true;
});
els.btnCamShotA.addEventListener('click', ()=> captureFrameToImage(els.video, els.imgA, ()=>aReady=true));
els.btnCamShotB.addEventListener('click', ()=> captureFrameToImage(els.video, els.imgB, ()=>bReady=true));
function captureFrameToImage(videoEl, targetImg, onOk){
  const c=document.createElement('canvas');
  const w=videoEl.videoWidth, h=videoEl.videoHeight;
  c.width=w; c.height=h;
  c.getContext('2d').drawImage(videoEl,0,0,w,h);
  targetImg.src=c.toDataURL('image/jpeg',0.92);
  targetImg.onload=()=>onOk&&onOk();
}

/* === YOLOv8 セッション＆OpenCV準備 === */
let yoloSession=null;
async function ensureYolo(){
  if(!yoloSession){
    yoloSession = await ort.InferenceSession.create('./yolov8n.onnx', {
      executionProviders: ['wasm'], graphOptimizationLevel: 'all'
    });
    console.log('YOLOv8 ONNX loaded');
    console.log('InputNames:', yoloSession.inputNames);
    console.log('OutputNames:', yoloSession.outputNames);
  }
}
function waitForCv(){
  return new Promise(resolve=>{
    if(window.__cvReady && window.cv && cv.Mat){ resolve(); return; }
    const t=setInterval(()=>{ if(window.__cvReady && window.cv && cv.Mat){ clearInterval(t); resolve(); } },50);
  });
}

/* === 前処理（letterbox 640x640） === */
function letterbox(imgEl, newShape=640, color=[114,114,114]){
  const iw = imgEl.naturalWidth, ih = imgEl.naturalHeight;
  const r = Math.min(newShape/iw, newShape/ih);
  const nw = Math.round(iw*r), nh = Math.round(ih*r);
  const px = Math.round((newShape - nw)/2), py = Math.round((newShape - nh)/2);

  const c = document.createElement('canvas'); c.width=newShape; c.height=newShape;
  const ctx = c.getContext('2d');
  ctx.fillStyle = `rgb(${color[0]},${color[1]},${color[2]})`;
  ctx.fillRect(0,0,newShape,newShape);
  ctx.drawImage(imgEl, 0,0, iw,ih, px,py, nw,nh);
  return {canvas:c, ratio:r, padX:px, padY:py, origW:iw, origH:ih};
}
function toCHWFloat32(canvas){
  const ctx = canvas.getContext('2d');
  const {width:w,height:h} = canvas;
  const img = ctx.getImageData(0,0,w,h).data; // RGBA
  const size = w*h;
  const data = new Float32Array(3*size);
  for(let i=0, p=0;i<size;i++,p+=4){
    data[i]        = img[p]   / 255.0; // R
    data[i+size]   = img[p+1] / 255.0; // G
    data[i+2*size] = img[p+2] / 255.0; // B
  }
  return data;
}

/* === 安全なシグモイド === */
const sigmoid = x => 1 / (1 + Math.exp(-x));

/* === 推論・後処理（YOLO：形状・活性化を自動吸収） === */
function robustDecodeYOLOv8(tensor, info, confThr=0.35, nmsIoU=0.45){
  const dims = tensor.dims || [];
  const data = tensor.data;
  let N=0, clsDim=80, stride=0, layout='84xN';
  if (dims.length === 3) {
    if (dims[1] === 84) { N = dims[2]; stride = N; layout = '84xN'; }
    else if (dims[2] === 84) { N = dims[1]; stride = 84; layout = 'Nx84'; }
  } else { N = 8400; stride = N; layout = '84xN'; }

  const boxes=[];
  for (let i=0;i<N;i++){
    let x,y,w,h,obj,startClsIdx;
    if (layout === '84xN'){
      x   = data[0*stride + i];
      y   = data[1*stride + i];
      w   = data[2*stride + i];
      h   = data[3*stride + i];
      obj = sigmoid(data[4*stride + i]);
      startClsIdx = 5*stride + i;
    }else{
      const base = i*stride;
      x   = data[base + 0];
      y   = data[base + 1];
      w   = data[base + 2];
      h   = data[base + 3];
      obj = sigmoid(data[base + 4]);
      startClsIdx = base + 5;
    }
    let best=0, cid=0;
    for (let c=0;c<clsDim;c++){
      const v = sigmoid(data[startClsIdx + c]);
      if (v>best){ best=v; cid=c; }
    }
    const conf = obj * best;
    if (conf < confThr) continue;

    const cx = x - info.padX, cy = y - info.padY;
    const gx = cx/info.ratio,  gy = cy/info.ratio;
    const gw = w/info.ratio,   gh = h/info.ratio;
    const x1 = Math.max(0, gx - gw/2), y1 = Math.max(0, gy - gh/2);
    const x2 = Math.min(info.origW, gx + gw/2), y2 = Math.min(info.origH, gy + gh/2);
    boxes.push({x1,y1,x2,y2, conf, cls:cid});
  }
  boxes.sort((a,b)=> b.conf - a.conf);
  const picked=[];
  const iou=(a,b)=>{
    const xx1=Math.max(a.x1,b.x1), yy1=Math.max(a.y1,b.y1);
    const xx2=Math.min(a.x2,b.x2), yy2=Math.min(a.y2,b.y2);
    const w=Math.max(0,xx2-xx1), h=Math.max(0,yy2-yy1);
    const inter=w*h;
    const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
    const union=areaA+areaB-inter;
    return union>0 ? inter/union : 0;
  };
  boxes.forEach(b=>{
    let keep=true; for(const p of picked){ if(iou(b,p)>nmsIoU){ keep=false; break; } }
    if(keep) picked.push(b);
  });
  return picked;
}

/* === 差分（複合コストで頑健化） === */
function iouRect(a,b){
  const xx1=Math.max(a.x1,b.x1), yy1=Math.max(a.y1,b.y1);
  const xx2=Math.min(a.x2,b.x2), yy2=Math.min(a.y2,b.y2);
  const w=Math.max(0,xx2-xx1), h=Math.max(0,yy2-yy1);
  const inter=w*h;
  const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
  const union=areaA+areaB-inter;
  return union>0 ? inter/union : 0;
}
function center(a){ return {cx:(a.x1+a.x2)/2, cy:(a.y1+a.y2)/2}; }
function area(a){ return Math.max(1, (a.x2-a.x1)*(a.y2-a.y1)); }
function pairwiseCost(a,b){
  const i = iouRect(a,b);
  const ca = center(a), cb = center(b);
  const d = Math.hypot(ca.cx-cb.cx, ca.cy-cb.cy);
  const s = Math.abs(area(a)-area(b))/Math.max(area(a),area(b));
  const classPenalty = (a.cls===b.cls) ? 0 : 0.15;
  return (1-i)*0.65 + (d/(Math.sqrt(area(a))+Math.sqrt(area(b))))*0.25 + s*0.10 + classPenalty;
}
function greedyAssign(A, B, costThr=0.45){
  const usedB = new Set();
  const matches = [];
  for(const a of A){
    let best = {j:-1, cost:1e9};
    for(let j=0;j<B.length;j++){
      if(usedB.has(j)) continue;
      const c = pairwiseCost(a,B[j]);
      if(c < best.cost) best={j, cost:c};
    }
    if(best.j>=0 && best.cost<=costThr){ usedB.add(best.j); matches.push([a, B[best.j]]); }
  }
  const unmatchedA = A.filter(a => !matches.some(m=>m[0]===a));
  const unmatchedB = B.filter((_,j)=> !usedB.has(j));
  return {matches, unmatchedA, unmatchedB};
}
function semanticDiffBothRobust(objsA, objsB){
  const {unmatchedA, unmatchedB} = greedyAssign(objsA, objsB, 0.45);
  return { diffA: unmatchedA, diffB: unmatchedB };
}

/* === 差分枠：NMS＆面積フィルタ＆Top‑K === */
function nmsDiff(boxes, iouThr=0.3){
  const iou = (a,b)=>{
    const xx1 = Math.max(a.x1,b.x1), yy1 = Math.max(a.y1,b.y1);
    const xx2 = Math.min(a.x2,b.x2), yy2 = Math.min(a.y2,b.y2);
    const w = Math.max(0, xx2-xx1), h = Math.max(0, yy2-yy1);
    const inter = w*h;
    const areaA = (a.x2-a.x1)*(a.y2-a.y1);
    const areaB = (b.x2-b.x1)*(b.y2-b.y1);
    const union = areaA + areaB - inter;
    return union>0 ? inter/union : 0;
  };
  const sorted = boxes.slice().sort((a,b)=> (b.conf||0)-(a.conf||0));
  const picked = [];
  sorted.forEach(b=>{
    let keep = true;
    for(const p of picked){ if(iou(b,p)>iouThr){ keep=false; break; } }
    if(keep) picked.push(b);
  });
  return picked;
}
function filterByArea(boxes, minArea){
  return boxes.filter(b => (b.x2-b.x1)*(b.y2-b.y1) >= minArea);
}
function topKByArea(boxes, k){
  const arr = boxes.slice().sort((a,b)=> ((b.x2-b.x1)*(b.y2-b.y1)) - ((a.x2-a.x1)*(a.y2-a.y1)));
  return arr.slice(0, k);
}

/* === マスク（基準側の大物体：UI可変） === */
function buildMaskFromDetections(W,H, objs, origW, origH){
  const c=document.createElement('canvas'); c.width=W; c.height=H;
  const ctx=c.getContext('2d');
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle='#fff';
  const pct = Math.max(0, parseFloat(els.maskPct.value)) / 100.0; // %
  const bigAreaThr = (W*H) * pct;
  objs.forEach(o=>{
    const w=(o.x2-o.x1), h=(o.y2-o.y1);
    if(w*h >= bigAreaThr){
      ctx.fillRect(o.x1*(W/origW), o.y1*(H/origH), w*(W/origW), h*(H/origH));
    }
  });
  return c;
}

/* === 位置補正（ECC：AFFINE→TRANSLATION） === */
function alignOtherToBaseCanvasAffine(baseImgEl, otherImgEl, W, H){
  const baseC=document.createElement('canvas'), otherC=document.createElement('canvas');
  baseC.width=W; baseC.height=H; otherC.width=W; otherC.height=H;
  baseC.getContext('2d').drawImage(baseImgEl,0,0,W,H);
  otherC.getContext('2d').drawImage(otherImgEl,0,0,W,H);
  try{
    const A=cv.imread(baseC), B=cv.imread(otherC);
    const gA=new cv.Mat(), gB=new cv.Mat();
    cv.cvtColor(A,gA,cv.COLOR_RGBA2GRAY);
    cv.cvtColor(B,gB,cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gA,gA,new cv.Size(3,3),0);
    cv.GaussianBlur(gB,gB,new cv.Size(3,3),0);

    const warp = cv.Mat.eye(2,3,cv.CV_32F);
    const criteria = new cv.TermCriteria(cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, 100, 1e-6);
    try{
      cv.findTransformECC(gA, gB, warp, cv.MOTION_AFFINE, criteria);
    }catch(_){
      cv.findTransformECC(gA, gB, warp, cv.MOTION_TRANSLATION, criteria);
    }
    const warped = new cv.Mat();
    cv.warpAffine(B, warped, warp, new cv.Size(W,H), cv.INTER_LINEAR, cv.BORDER_REFLECT);
    cv.imshow(otherC, warped);

    [A,B,gA,gB,warp,warped].forEach(m=>m.delete());
    return otherC;
  }catch(e){
    console.warn('位置補正失敗：', e);
    return otherC;
  }
}

/* === OpenCVヒート：Lab-L＋Otsuで露出耐性UP === */
function cvDiffHeatBetter(baseImgEl, otherCanvas, outCanvas, maskCanvas, thrVal){
  const W=outCanvas.width, H=outCanvas.height;

  const tmpA=document.createElement('canvas'); tmpA.width=W; tmpA.height=H;
  tmpA.getContext('2d').drawImage(baseImgEl,0,0,W,H);

  const matA=cv.imread(tmpA), matB=cv.imread(otherCanvas);
  const labA=new cv.Mat(), labB=new cv.Mat();
  cv.cvtColor(matA,labA,cv.COLOR_RGBA2RGB);
  cv.cvtColor(matB,labB,cv.COLOR_RGBA2RGB);
  cv.cvtColor(labA,labA,cv.COLOR_RGB2Lab);
  cv.cvtColor(labB,labB,cv.COLOR_RGB2Lab);

  const channelsA=new cv.MatVector(), channelsB=new cv.MatVector();
  cv.split(labA,channelsA); cv.split(labB,channelsB);
  const LA=channelsA.get(0), LB=channelsB.get(0);

  const diff=new cv.Mat(); cv.absdiff(LA,LB,diff);
  cv.GaussianBlur(diff,diff,new cv.Size(5,5),0);

  const maskMat=cv.imread(maskCanvas);
  const maskGray=new cv.Mat(); cv.cvtColor(maskMat,maskGray,cv.COLOR_RGBA2GRAY);
  const invMask=new cv.Mat(); cv.threshold(maskGray,invMask,128,255,cv.THRESH_BINARY_INV);
  const masked=new cv.Mat(); cv.bitwise_and(diff,invMask,masked);

  const bw=new cv.Mat();
  if(thrVal<=0){ cv.threshold(masked,bw,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU); }
  else { cv.threshold(masked,bw,thrVal,255,cv.THRESH_BINARY); }

  const heat=new cv.Mat();
  cv.applyColorMap(bw, heat, cv.COLORMAP_TURBO);

  const ctx=outCanvas.getContext('2d');
  ctx.save();
  ctx.globalAlpha = 0.35;
  const heatCanvas=document.createElement('canvas'); heatCanvas.width=W; heatCanvas.height=H;
  cv.imshow(heatCanvas, heat);
  ctx.drawImage(heatCanvas,0,0);
  ctx.restore();

  [matA,matB,labA,labB,channelsA,channelsB,LA,LB,diff,maskMat,maskGray,invMask,masked,bw,heat]
    .forEach(m=>{ try{ m.delete(); }catch(_){ }});
  return true;
}

/* === バッジ（簡易） === */
function drawBadge(ctx, text, ok=true){
  const W=ctx.canvas.width;
  ctx.save();
  ctx.font = `${Math.max(16, Math.floor(W/48))}px system-ui`;
  const pad=10;
  const txtW = ctx.measureText(text).width + pad*2;
  const txtH = Math.max(28, Math.floor(W/32));
  ctx.fillStyle = ok ? 'rgba(46,204,113,0.9)' : 'rgba(231,76,60,0.9)';
  ctx.fillRect(pad, pad, txtW, txtH);
  ctx.strokeStyle='rgba(0,0,0,0.3)'; ctx.lineWidth=2;
  ctx.strokeRect(pad, pad, txtW, txtH);
  ctx.fillStyle='#fff';
  ctx.fillText(text, pad+6, pad+txtH*0.7);
  ctx.restore();
}

/* === 描画（基準切替＋表現切替） === */
function drawWithBase(base, renderMode, imgA, imgB, detA, detB, diffA, diffB){
  const baseImg   = (base==='A') ? imgA : imgB;
  const otherImg  = (base==='A') ? imgB : imgA;
  const baseDet   = (base==='A') ? detA : detB;
  let boxes       = (base==='A') ? diffB.map(d=>({...d})) : diffA.map(d=>({...d}));

  const ctx = els.canvas.getContext('2d');
  const MAX_W = parseInt(els.maxW.value,10);
  const ratio = Math.min(1, MAX_W / baseImg.naturalWidth);
  const W = Math.round(baseImg.naturalWidth * ratio);
  const H = Math.round(baseImg.naturalHeight * ratio);
  els.canvas.width = W; els.canvas.height = H;
  ctx.drawImage(baseImg, 0, 0, W, H);

  // 位置補正（AFFINE）
  let otherAlignedCanvas;
  if(els.chkAlign.checked){
    otherAlignedCanvas = alignOtherToBaseCanvasAffine(baseImg, otherImg, W, H);
  }else{
    otherAlignedCanvas = document.createElement('canvas'); otherAlignedCanvas.width=W; otherAlignedCanvas.height=H;
    otherAlignedCanvas.getContext('2d').drawImage(otherImg,0,0,W,H);
  }

  // マスク（基準側の大物）
  const mask = buildMaskFromDetections(W,H, baseDet, baseImg.naturalWidth, baseImg.naturalHeight);

  const sx = W / baseImg.naturalWidth, sy = H / baseImg.naturalHeight;
  let hasChange=false;

  if(renderMode==='boxes'){
    const minAreaRatio = parseFloat(els.minArea.value)/100.0;
    const minAreaPx = minAreaRatio * (baseImg.naturalWidth * baseImg.naturalHeight);
    boxes = filterByArea(boxes, minAreaPx);
    boxes = nmsDiff(boxes, 0.35);
    boxes = topKByArea(boxes, parseInt(els.topK.value,10));

    ctx.lineWidth = Math.max(3, Math.floor(W/512));
    if(base==='A'){ ctx.strokeStyle='rgba(64,128,255,0.98)'; ctx.fillStyle='rgba(64,128,255,0.20)'; }
    else          { ctx.strokeStyle='rgba(255,160,64,0.98)'; ctx.fillStyle='rgba(255,160,64,0.20)'; }
    boxes.forEach(b=>{
      const x=b.x1*sx, y=b.y1*sy, w=(b.x2-b.x1)*sx, h=(b.y2-b.y1)*sy;
      ctx.fillRect(x,y,w,h); ctx.strokeRect(x,y,w,h);
    });
    hasChange = boxes.length>0;
  }else{
    hasChange = cvDiffHeatBetter(baseImg, otherAlignedCanvas, els.canvas, mask, parseInt(els.cvThr.value,10));
  }

  const label = (base==='A') ? 'Bに追加の差分' : 'Aに追加の差分';
  drawBadge(ctx, hasChange ? `あり：${label}` : 'なし：顕著な差分なし', hasChange);
}

/* === 推論ボタン（入力キー自動） === */
els.btnDetect.addEventListener('click', async ()=>{
  if(!aReady || !bReady){ alert('画像A・画像Bを選択（または撮影）してください'); return; }
  els.btnDetect.disabled = true; els.btnDetect.textContent = '推論中…';
  try{
    await ensureYolo();
    await waitForCv();

    const lbA = letterbox(els.imgA, 640);
    const lbB = letterbox(els.imgB, 640);
    const inputA = new ort.Tensor('float32', toCHWFloat32(lbA.canvas), [1,3,640,640]);
    const inputB = new ort.Tensor('float32', toCHWFloat32(lbB.canvas), [1,3,640,640]);

    const inName  = yoloSession.inputNames[0];
    const outName = yoloSession.outputNames[0];

    const feedsA = {}; feedsA[inName] = inputA;
    const feedsB = {}; feedsB[inName] = inputB;

    const confThr = parseFloat(els.confThr.value);
    const nmsIoU  = parseFloat(els.nmsThr.value);

    const outA = await yoloSession.run(feedsA);
    const outB = await yoloSession.run(feedsB);

    const tensorA = outA[outName] || Object.values(outA)[0];
    const tensorB = outB[outName] || Object.values(outB)[0];

    const detA = robustDecodeYOLOv8(tensorA, {ratio:lbA.ratio, padX:lbA.padX, padY:lbA.padY, origW:lbA.origW, origH:lbA.origH}, confThr, nmsIoU);
    const detB = robustDecodeYOLOv8(tensorB, {ratio:lbB.ratio, padX:lbB.padX, padY:lbB.padY, origW:lbB.origW, origH:lbB.origH}, confThr, nmsIoU);

    const {diffA, diffB} = semanticDiffBothRobust(detA, detB);

    const base = els.baseA.checked ? 'A' : 'B';
    const renderMode = els.modeHeat.checked ? 'heat' : 'boxes';
    drawWithBase(base, renderMode, els.imgA, els.imgB, detA, detB, diffA, diffB);

    els.btnSaveJpg.disabled = true;
    setTimeout(()=>{ els.btnSaveJpg.disabled = false; }, 120);
  }catch(e){
    console.error(e);
    alert(`推論/差分でエラー：${e.message}`);
  }finally{
    els.btnDetect.disabled = false; els.btnDetect.textContent = '差分を検出';
  }
});

/* === 保存 === */
els.btnSaveJpg.addEventListener('click', ()=>{
  const dataUrl = els.canvas.toDataURL('image/jpeg', 0.88);
  const a=document.createElement('a');
  a.href=dataUrl;
  a.download=`差分結果_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.jpg`;
  a.click();
});
</script>
</body>
</html>
