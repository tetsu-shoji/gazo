
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>写真の差分検出（基準切替・YOLOv8＋OpenCV）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{ --bg:#0b132b; --panel:#1c2541; --text:#eaeaea; --accent:#5bc0be; }
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,"Segoe UI",sans-serif;}
    header{padding:14px 18px;background:var(--panel);border-bottom:1px solid #2f3b66;}
    header h1{margin:0;font-size:18px}
    main{padding:16px;display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .card{background:var(--panel);border:1px solid #2f3b66;border-radius:10px;padding:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label.btn{background:#3a506b;color:#d6eaff;padding:10px 12px;border-radius:8px;cursor:pointer}
    input[type=file]{display:none}
    canvas, img{max-width:100%;height:auto;border-radius:6px;border:1px solid #2f3b66;background:#000}
    img{display:block}
    .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px}
    .control{background:#162447;border:1px solid #2f3b66;border-radius:8px;padding:8px}
    .control label{display:block;font-size:12px;margin-bottom:6px;opacity:.85}
    .btn{background:var(--accent);color:#012a36;border:none;border-radius:8px;padding:10px 12px;font-weight:700;cursor:pointer}
    .btn.secondary{background:#3a506b;color:#d6eaff}
    .small{font-size:12px;opacity:.8}
    @media (max-width:900px){ main{grid-template-columns:1fr} }
    .toggle{display:flex;gap:12px;align-items:center}
    .legend{font-size:12px;opacity:.8;margin-top:6px}
  </style>
  <!-- OpenCV.js 初期化通知 -->
  <script>
    window.__cvReady = false;
    window.Module = { onRuntimeInitialized(){ window.__cvReady = true; console.log('OpenCV.js ready'); } };
  </script>
</head>
<body>
<header><h1>写真の差分検出（基準切替・YOLOv8＋OpenCV）</h1></header>

<main>
  <!-- 左：入力 -->
  <section class="card">
    <h2 style="margin:0 0 8px">入力画像</h2>
    <div class="row">
      <label class="btn">画像Aを選択<input id="fileA" type="file" accept="image/*" /></label>
      <label class="btn">画像Bを選択<input id="fileB" type="file" accept="image/*" /></label>
      <button id="btnDetect" class="btn">差分を検出</button>
      <button id="btnSaveJpg" class="btn secondary" disabled>JPEGで保存</button>
    </div>

    <div class="toggle">
      <span>基準画像：</span>
      <label><input type="radio" name="base" id="baseA" value="A" checked> A（Bに追加を検出）</label>
      <label><input type="radio" name="base" id="baseB" value="B"> B（Aに追加を検出）</label>
    </div>
    <p class="legend">
      ・A基準：<span style="color:#80a0ff">青枠</span>＝Bにだけある差分（例：Bのペン）／<span style="color:#ff4040">赤</span>＝画素最大差分<br>
      ・B基準：<span style="color:#ffa040">橙枠</span>＝Aにだけある差分／<span style="color:#ff4040">赤</span>＝画素最大差分
    </p>

    <div class="controls">
      <div class="control">
        <label>YOLO 信頼度しきい値 <span id="confVal">0.35</span></label>
        <input id="confThr" type="range" min="0.1" max="0.9" step="0.05" value="0.35">
      </div>
      <div class="control">
        <label>YOLO NMS IoU <span id="nmsVal">0.45</span></label>
        <input id="nmsThr" type="range" min="0.2" max="0.9" step="0.05" value="0.45">
      </div>
      <div class="control">
        <label>差分IoU（位置一致判定） <span id="iouVal">0.45</span></label>
        <input id="iouThr" type="range" min="0.2" max="0.9" step="0.05" value="0.45">
      </div>
      <div class="control">
        <label>サイズ差しきい値（面積相対差） <span id="sizeVal">0.50</span></label>
        <input id="sizeThr" type="range" min="0.1" max="0.9" step="0.05" value="0.50">
      </div>
      <div class="control">
        <label>OpenCV差分しきい値 <span id="cvThrVal">40</span></label>
        <input id="cvThr" type="range" min="20" max="80" step="2" value="40">
      </div>
      <div class="control">
        <label>最小差分面積（%） <span id="minAreaVal">0.10</span></label>
        <input id="minArea" type="range" min="0.02" max="0.50" step="0.02" value="0.10">
      </div>
      <div class="control">
        <label>枠数の上限（Top-K） <span id="topKVal">5</span></label>
        <input id="topK" type="range" min="1" max="12" step="1" value="5">
      </div>
      <div class="control">
        <label>最大表示幅（px） <span id="maxWVal">1024</span></label>
        <input id="maxW" type="range" min="640" max="1920" step="64" value="1024">
      </div>
    </div>

    <p class="small">※ 画像プレビューで表示できない場合はHEICの可能性があります。JPEG/PNGでお試しください。</p>
    <div class="row">
      <figure style="flex:1"><figcaption>画像Aプレビュー</figcaption><img id="imgA" alt=""></figure>
      <figure style="flex:1"><figcaption>画像Bプレビュー</figcaption><img id="imgB" alt=""></figure>
    </div>
  </section>

  <!-- 右：結果 -->
  <section class="card">
    <h2 style="margin:0 0 8px">結果（少数枠＋最大差分強調）</h2>
    <canvas id="canvas" width="1024" height="768"></canvas>
    <p class="small">下地は<strong>基準画像</strong>。検出枠は少数化（NMS＋面積しきい値＋Top-K）、OpenCVは最大コンポーネントのみ赤で重ねています。</p>
  </section>
</main>

<!-- 依存ライブラリ（CDN）。オフライン時は lib/ に同梱して相対パスに変更 -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* === UI参照 === */
const els = {
  fileA: document.getElementById('fileA'),
  fileB: document.getElementById('fileB'),
  imgA: document.getElementById('imgA'),
  imgB: document.getElementById('imgB'),
  canvas: document.getElementById('canvas'),
  btnDetect: document.getElementById('btnDetect'),
  btnSaveJpg: document.getElementById('btnSaveJpg'),
  baseA: document.getElementById('baseA'),
  baseB: document.getElementById('baseB'),
  confThr: document.getElementById('confThr'),
  nmsThr: document.getElementById('nmsThr'),
  iouThr: document.getElementById('iouThr'),
  sizeThr: document.getElementById('sizeThr'),
  cvThr: document.getElementById('cvThr'),
  minArea: document.getElementById('minArea'),
  topK: document.getElementById('topK'),
  maxW: document.getElementById('maxW'),
  confVal: document.getElementById('confVal'),
  nmsVal: document.getElementById('nmsVal'),
  iouVal: document.getElementById('iouVal'),
  sizeVal: document.getElementById('sizeVal'),
  cvThrVal: document.getElementById('cvThrVal'),
  minAreaVal: document.getElementById('minAreaVal'),
  topKVal: document.getElementById('topKVal'),
  maxWVal: document.getElementById('maxWVal'),
};
let aReady=false, bReady=false;

/* === 画像読み込み（createObjectURL／HEIC検知） === */
els.fileA.addEventListener('change', e => loadViaObjectURL(e.target.files?.[0], els.imgA, () => aReady=true));
els.fileB.addEventListener('change', e => loadViaObjectURL(e.target.files?.[0], els.imgB, () => bReady=true));
function loadViaObjectURL(file, imgEl, onOk){
  if(!file){ alert('ファイルが選択されていません'); return; }
  const mime = (file.type||'').toLowerCase();
  if(!mime.startsWith('image/')){ alert('画像ファイルを選択してください（JPEG/PNG推奨）'); return; }
  if(mime.includes('heic') || mime.includes('heif')){
    alert('HEIC/HEIFは表示できない場合があります。JPEG/PNGでお試しください。'); return;
  }
  const url = URL.createObjectURL(file);
  imgEl.onload = ()=>{ URL.revokeObjectURL(url); onOk&&onOk(); };
  imgEl.onerror = ()=>{ URL.revokeObjectURL(url); alert('画像の読み込みに失敗しました。'); };
  imgEl.src = url;
}

/* === しきい値表示 === */
function updateVals(){
  els.confVal.textContent = parseFloat(els.confThr.value).toFixed(2);
  els.nmsVal.textContent  = parseFloat(els.nmsThr.value).toFixed(2);
  els.iouVal.textContent  = parseFloat(els.iouThr.value).toFixed(2);
  els.sizeVal.textContent = parseFloat(els.sizeThr.value).toFixed(2);
  els.cvThrVal.textContent= parseInt(els.cvThr.value,10);
  els.minAreaVal.textContent= parseFloat(els.minArea.value).toFixed(2);
  els.topKVal.textContent    = parseInt(els.topK.value,10);
  els.maxWVal.textContent    = parseInt(els.maxW.value,10);
}
['confThr','nmsThr','iouThr','sizeThr','cvThr','minArea','topK','maxW'].forEach(id=>els[id].addEventListener('input',updateVals));
updateVals();

/* === YOLOv8 セッション＆OpenCV待機 === */
let yoloSession=null;
async function ensureYolo(){
  if(!yoloSession){
    // モデルは index.html と同じ階層に配置
    yoloSession = await ort.InferenceSession.create('./yolov8n.onnx', {
      executionProviders: ['wasm'], graphOptimizationLevel: 'all'
    });
    console.log('YOLOv8 ONNX loaded');
  }
}
function waitForCv(){
  return new Promise(resolve=>{
    if(window.__cvReady && window.cv && cv.Mat){ resolve(); return; }
    const t=setInterval(()=>{ if(window.__cvReady && window.cv && cv.Mat){ clearInterval(t); resolve(); } },50);
  });
}

/* === 前処理（letterbox 640x640） === */
function letterbox(imgEl, newShape=640, color=[114,114,114]){
  const iw = imgEl.naturalWidth, ih = imgEl.naturalHeight;
  const r = Math.min(newShape/iw, newShape/ih);
  const nw = Math.round(iw*r), nh = Math.round(ih*r);
  const px = Math.round((newShape - nw)/2), py = Math.round((newShape - nh)/2);

  const c = document.createElement('canvas'); c.width=newShape; c.height=newShape;
  const ctx = c.getContext('2d');
  ctx.fillStyle = `rgb(${color[0]},${color[1]},${color[2]})`;
  ctx.fillRect(0,0,newShape,newShape);
  ctx.drawImage(imgEl, 0,0, iw,ih, px,py, nw,nh);
  return {canvas:c, ratio:r, padX:px, padY:py, origW:iw, origH:ih};
}
function toCHWFloat32(canvas){
  const ctx = canvas.getContext('2d');
  const {width:w,height:h} = canvas;
  const img = ctx.getImageData(0,0,w,h).data; // RGBA
  const size = w*h;
  const data = new Float32Array(3*size);
  for(let i=0, p=0;i<size;i++,p+=4){
    data[i]        = img[p]   / 255.0; // R
    data[i+size]   = img[p+1] / 255.0; // G
    data[i+2*size] = img[p+2] / 255.0; // B
  }
  return data;
}

/* === 推論・後処理 === */
// Ultralytics YOLOv8（640）出力想定: [1,84,8400] → Float32Array [84,8400]
function decodeYOLOv8(outData, info, confThr=0.35, nmsIoU=0.45){
  const numPred = 8400, numCls = 80, stride = numPred;
  const boxes=[];
  for(let i=0;i<numPred;i++){
    const x = outData[0*stride+i], y = outData[1*stride+i];
    const w = outData[2*stride+i], h = outData[3*stride+i];
    const obj = outData[4*stride+i];
    let best=0, cid=0;
    for(let c=0;c<numCls;c++){
      const v = outData[(5+c)*stride + i];
      if(v>best){ best=v; cid=c; }
    }
    const conf = obj*best;
    if(conf < confThr) continue;

    const cx = x - info.padX, cy = y - info.padY;
    const gx = cx/info.ratio,  gy = cy/info.ratio;
    const gw = w/info.ratio,   gh = h/info.ratio;
    const x1 = Math.max(0, gx - gw/2), y1 = Math.max(0, gy - gh/2);
    const x2 = Math.min(info.origW, gx + gw/2), y2 = Math.min(info.origH, gy + gh/2);
    boxes.push({x1,y1,x2,y2, conf, cls:cid});
  }
  // NMS
  boxes.sort((a,b)=>b.conf-a.conf);
  const picked=[];
  const iou = (a,b)=>{
    const xx1=Math.max(a.x1,b.x1), yy1=Math.max(a.y1,b.y1);
    const xx2=Math.min(a.x2,b.x2), yy2=Math.min(a.y2,b.y2);
    const w=Math.max(0,xx2-xx1), h=Math.max(0,yy2-yy1);
    const inter=w*h;
    const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
    const union=areaA+areaB-inter;
    return union>0 ? inter/union : 0;
  };
  boxes.forEach(b=>{
    let keep=true; for(const p of picked){ if(iou(b,p)>nmsIoU){ keep=false; break; } }
    if(keep) picked.push(b);
  });
  return picked;
}

/* 差分（双方向） */
function iouRect(a,b){
  const xx1=Math.max(a.x1,b.x1), yy1=Math.max(a.y1,b.y1);
  const xx2=Math.min(a.x2,b.x2), yy2=Math.min(a.y2,b.y2);
  const w=Math.max(0,xx2-xx1), h=Math.max(0,yy2-yy1);
  const inter=w*h;
  const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
  const union=areaA+areaB-inter;
  return union>0 ? inter/union : 0;
}
function diffOneWay(objsA, objsB, iouThr, sizeRatioThr){
  const diffs=[];
  objsA.forEach(a=>{
    const cand = objsB.filter(b=>b.cls===a.cls);
    let matched=false;
    for(const b of cand){
      const i = iouRect(a,b);
      const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
      const sizeRatio = Math.abs(areaA-areaB)/Math.max(areaA,areaB);
      if(i>=iouThr && sizeRatio<=sizeRatioThr){ matched=true; break; }
    }
    if(!matched) diffs.push(a);
  });
  return diffs;
}
function semanticDiffBoth(objsA, objsB, iouThr, sizeRatioThr){
  return { diffA: diffOneWay(objsA,objsB,iouThr,sizeRatioThr), diffB: diffOneWay(objsB,objsA,iouThr,sizeRatioThr) };
}

/* 差分枠用NMS＆フィルタ＆Top-K */
function nmsDiff(boxes, iouThr=0.3){
  const iou = (a,b)=>{
    const xx1 = Math.max(a.x1,b.x1), yy1 = Math.max(a.y1,b.y1);
    const xx2 = Math.min(a.x2,b.x2), yy2 = Math.min(a.y2,b.y2);
    const w = Math.max(0, xx2-xx1), h = Math.max(0, yy2-yy1);
    const inter = w*h;
    const areaA = (a.x2-a.x1)*(a.y2-a.y1);
    const areaB = (b.x2-b.x1)*(b.y2-b.y1);
    const union = areaA + areaB - inter;
    return union>0 ? inter/union : 0;
  };
  const sorted = boxes.slice().sort((a,b)=> (b.conf||0)-(a.conf||0));
  const picked = [];
  sorted.forEach(b=>{
    let keep = true;
    for(const p of picked){ if(iou(b,p)>iouThr){ keep=false; break; } }
    if(keep) picked.push(b);
  });
  return picked;
}
function filterByArea(boxes, minArea){
  return boxes.filter(b => (b.x2-b.x1)*(b.y2-b.y1) >= minArea);
}
function topKByArea(boxes, k){
  const arr = boxes.slice().sort((a,b)=> ((b.x2-b.x1)*(b.y2-b.y1)) - ((a.x2-a.x1)*(a.y1-a.y1)));
  // 修正: 上の式にバグがあるため正しく書き直し
  arr.sort((a,b)=> ((b.x2-b.x1)*(b.y2-b.y1)) - ((a.x2-a.x1)*(a.y2-a.y1)));
  return arr.slice(0, k);
}

/* マスク（基準側の大物体） */
function buildMaskFromDetections(W,H, objs, origW, origH){
  const c=document.createElement('canvas'); c.width=W; c.height=H;
  const ctx=c.getContext('2d');
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle='#fff';
  const bigAreaThr=(W*H)*0.002; // 0.2%以上を「大物」
  objs.forEach(o=>{
    const w=(o.x2-o.x1), h=(o.y2-o.y1);
    if(w*h>=bigAreaThr){
      ctx.fillRect(o.x1*(W/origW), o.y1*(H/origH), w*(W/origW), h*(H/origH));
    }
  });
  return c;
}

/* OpenCV差分：最大コンポーネントのみ */
function cvDiffLargestComponent(imgBase, imgOther, outCanvas, maskCanvas, thrVal){
  const W=outCanvas.width, H=outCanvas.height;
  const tmpA=document.createElement('canvas'), tmpB=document.createElement('canvas');
  tmpA.width=W; tmpA.height=H; tmpB.width=W; tmpB.height=H;
  tmpA.getContext('2d').drawImage(imgBase,0,0,W,H);
  tmpB.getContext('2d').drawImage(imgOther,0,0,W,H);

  const matA=cv.imread(tmpA), matB=cv.imread(tmpB);
  const gA=new cv.Mat(), gB=new cv.Mat();
  cv.cvtColor(matA,gA,cv.COLOR_RGBA2GRAY);
  cv.cvtColor(matB,gB,cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gA,gA,new cv.Size(5,5),0);
  cv.GaussianBlur(gB,gB,new cv.Size(5,5),0);

  const diff=new cv.Mat(); cv.absdiff(gA,gB,diff); cv.normalize(diff,diff,0,255,cv.NORM_MINMAX);

  const maskMat=cv.imread(maskCanvas);
  const maskGray=new cv.Mat(); cv.cvtColor(maskMat,maskGray,cv.COLOR_RGBA2GRAY);
  const invMask=new cv.Mat(); cv.threshold(maskGray,invMask,128,255,cv.THRESH_BINARY_INV);

  const masked=new cv.Mat(); cv.bitwise_and(diff,invMask,masked);

  const bw=new cv.Mat(); cv.threshold(masked,bw,thrVal,255,cv.THRESH_BINARY);
  const kernel=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(3,3));
  cv.morphologyEx(bw,bw,cv.MORPH_OPEN,kernel);
  cv.dilate(bw,bw,kernel);

  const contours=new cv.MatVector(); const hierarchy=new cv.Mat();
  cv.findContours(bw,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  let maxArea=0, maxRect=null;
  for(let i=0;i<contours.size();i++){
    const r=cv.boundingRect(contours.get(i));
    const area=r.width*r.height;
    if(area>maxArea){ maxArea=area; maxRect=r; }
  }

  const ctx=outCanvas.getContext('2d');
  if(maxRect){
    ctx.strokeStyle='rgba(255,64,64,0.98)';
    ctx.fillStyle  ='rgba(255,64,64,0.22)';
    ctx.lineWidth=Math.max(3,Math.floor(W/512));
    ctx.fillRect(maxRect.x, maxRect.y, maxRect.width, maxRect.height);
    ctx.strokeRect(maxRect.x, maxRect.y, maxRect.width, maxRect.height);
  }

  [matA,matB,gA,gB,diff,maskMat,maskGray,invMask,masked,bw,contours,hierarchy,kernel].forEach(m=>m.delete());
  return !!maxRect;
}

/* バッジ（角丸なしの簡易） */
function drawBadge(ctx, text, ok=true){
  const W=ctx.canvas.width;
  ctx.save();
  ctx.font = `${Math.max(16, Math.floor(W/48))}px system-ui`;
  const pad=10;
  const txtW = ctx.measureText(text).width + pad*2;
  const txtH = Math.max(28, Math.floor(W/32));
  ctx.fillStyle = ok ? 'rgba(46,204,113,0.9)' : 'rgba(231,76,60,0.9)';
  ctx.fillRect(pad, pad, txtW, txtH);
  ctx.strokeStyle='rgba(0,0,0,0.3)'; ctx.lineWidth=2;
  ctx.strokeRect(pad, pad, txtW, txtH);
  ctx.fillStyle='#fff';
  ctx.fillText(text, pad+6, pad+txtH*0.7);
  ctx.restore();
}

/* 描画（基準切替） */
function drawWithBase(base, imgA, imgB, detA, detB, diffA, diffB){
  // base='A'ならB\A、base='B'ならA\B
  const baseImg   = (base==='A') ? imgA : imgB;
  const otherImg  = (base==='A') ? imgB : imgA;
  const baseDet   = (base==='A') ? detA : detB;
  let boxes       = (base==='A') ? diffB.map(d=>({...d})) : diffA.map(d=>({...d}));
  const ctx = els.canvas.getContext('2d');

  // 出力サイズ
  const MAX_W = parseInt(els.maxW.value,10);
  const ratio = Math.min(1, MAX_W / baseImg.naturalWidth);
  const W = Math.round(baseImg.naturalWidth * ratio);
  const H = Math.round(baseImg.naturalHeight * ratio);
  els.canvas.width = W; els.canvas.height = H;

  // 下地
  ctx.drawImage(baseImg, 0, 0, W, H);

  // 少数化：面積しきい値→NMS→Top-K
  const minAreaRatio = parseFloat(els.minArea.value)/100.0; // % を倍率へ
  const minAreaPx = minAreaRatio * (baseImg.naturalWidth * baseImg.naturalHeight);
  boxes = filterByArea(boxes, minAreaPx);
  boxes = nmsDiff(boxes, 0.35);
  boxes = topKByArea(boxes, parseInt(els.topK.value,10));

  // 枠色
  const sx = W / baseImg.naturalWidth;
  const sy = H / baseImg.naturalHeight;
  ctx.lineWidth = Math.max(3, Math.floor(W/512));
  if(base==='A'){ // Bに追加 → 青
    ctx.strokeStyle='rgba(64,128,255,0.98)';
    ctx.fillStyle  ='rgba(64,128,255,0.20)';
  }else{          // Aに追加 → 橙
    ctx.strokeStyle='rgba(255,160,64,0.98)';
    ctx.fillStyle  ='rgba(255,160,64,0.20)';
  }
  boxes.forEach(b=>{
    const x=b.x1*sx, y=b.y1*sy, w=(b.x2-b.x1)*sx, h=(b.y2-b.y1)*sy;
    ctx.fillRect(x,y,w,h);
    ctx.strokeRect(x,y,w,h);
  });

  // 基準側の大物でマスク → OpenCV最大差分（赤）
  const mask = buildMaskFromDetections(W,H, baseDet, baseImg.naturalWidth, baseImg.naturalHeight);
  const hasLargest = cvDiffLargestComponent(baseImg, otherImg, els.canvas, mask, parseInt(els.cvThr.value,10));

  // バッジ
  const hasBoxes = boxes.length>0 || hasLargest;
  const label = (base==='A') ? 'Bに追加の小物差分（ペン等）' : 'Aに追加の小物差分（ペン等）';
  drawBadge(ctx, hasBoxes ? `あり：${label}` : 'なし：小物差分なし', hasBoxes);
}

/* 実行・保存 */
els.btnDetect.addEventListener('click', async ()=>{
  if(!aReady || !bReady){ alert('画像A・画像Bを選択してください'); return; }
  els.btnDetect.disabled = true; els.btnDetect.textContent = '推論中…';
  try{
    await ensureYolo();
    await waitForCv();

    // 前処理
    const lbA = letterbox(els.imgA, 640);
    const lbB = letterbox(els.imgB, 640);
    const inputA = new ort.Tensor('float32', toCHWFloat32(lbA.canvas), [1,3,640,640]);
    const inputB = new ort.Tensor('float32', toCHWFloat32(lbB.canvas), [1,3,640,640]);

    // 入出力名で実行（※名前キーが重要）
    const inName = yoloSession.inputNames[0];
    const outName = yoloSession.outputNames[0];

    const confThr = parseFloat(els.confThr.value);
    const nmsIoU  = parseFloat(els.nmsThr.value);

    const outA = await yoloSession.run({ [inName]: inputA });
    const outB = await yoloSession.run({ [inName]: inputB });

    const detA = decodeYOLOv8(outA[outName].data, {ratio:lbA.ratio, padX:lbA.padX, padY:lbA.padY, origW:lbA.origW, origH:lbA.origH}, confThr, nmsIoU);
    const detB = decodeYOLOv8(outB[outName].data, {ratio:lbB.ratio, padX:lbB.padX, padY:lbB.padY, origW:lbB.origW, origH:lbB.origH}, confThr, nmsIoU);

    const {diffA, diffB} = semanticDiffBoth(detA, detB, parseFloat(els.iouThr.value), parseFloat(els.sizeThr.value));

    // 基準切替
    const base = els.baseA.checked ? 'A' : 'B';
    drawWithBase(base, els.imgA, els.imgB, detA, detB, diffA, diffB);

    els.btnSaveJpg.disabled = true;
    setTimeout(()=>{ els.btnSaveJpg.disabled = false; }, 120);
  }catch(e){
    console.error(e);
    alert('推論/差分でエラー：'+ e.message);
  }finally{
    els.btnDetect.disabled = false; els.btnDetect.textContent = '差分を検出';
  }
});

els.btnSaveJpg.addEventListener('click', ()=>{
  const dataUrl = els.canvas.toDataURL('image/jpeg', 0.85);
  const a=document.createElement('a');
  a.href=dataUrl;
  a.download=`差分結果_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.jpg`;
  a.click();
});
</script>
</body>
</html>
