
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>写真の差分検出（YOLOv8 Web＋OpenCVハイブリッド）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{ --bg:#0b132b; --panel:#1c2541; --text:#eaeaea; --accent:#5bc0be; }
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,"Segoe UI",sans-serif;}
    header{padding:14px 18px;background:var(--panel);border-bottom:1px solid #2f3b66;}
    header h1{margin:0;font-size:18px}
    main{padding:16px;display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .card{background:var(--panel);border:1px solid #2f3b66;border-radius:10px;padding:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label.btn{background:#3a506b;color:#d6eaff;padding:10px 12px;border-radius:8px;cursor:pointer}
    input[type=file]{display:none}
    canvas, img{max-width:100%;height:auto;border-radius:6px;border:1px solid #2f3b66;background:#000}
    img{display:block}
    .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px}
    .control{background:#162447;border:1px solid #2f3b66;border-radius:8px;padding:8px}
    .control label{display:block;font-size:12px;margin-bottom:6px;opacity:.85}
    .btn{background:var(--accent);color:#012a36;border:none;border-radius:8px;padding:10px 12px;font-weight:700;cursor:pointer}
    .btn.secondary{background:#3a506b;color:#d6eaff}
    .small{font-size:12px;opacity:.8}
    @media (max-width:900px){ main{grid-template-columns:1fr} }
  </style>
  <!-- OpenCV.js 初期化通知（onRuntimeInitialized を受けるため） -->
  <script>
    window.__cvReady = false;
    window.Module = { onRuntimeInitialized(){ window.__cvReady = true; console.log('OpenCV.js ready'); } };
  </script>
</head>
<body>
<header><h1>写真の差分検出（YOLOv8＋OpenCV）</h1></header>

<main>
  <section class="card">
    <h2 style="margin:0 0 8px">入力画像</h2>
    <div class="row">
      <label class="btn">画像Aを選択<input id="fileA" type="file" accept="image/*" /></label>
      <label class="btn">画像Bを選択<input id="fileB" type="file" accept="image/*" /></label>
      <button id="btnDetect" class="btn">差分を検出</button>
      <button id="btnSaveJpg" class="btn secondary" disabled>JPEGで保存</button>
    </div>

    <div class="controls">
      <div class="control">
        <label>YOLO 信頼度しきい値 <span id="confVal">0.35</span></label>
        <input id="confThr" type="range" min="0.1" max="0.9" step="0.05" value="0.35">
      </div>
      <div class="control">
        <label>YOLO NMS IoU <span id="nmsVal">0.45</span></label>
        <input id="nmsThr" type="range" min="0.2" max="0.9" step="0.05" value="0.45">
      </div>
      <div class="control">
        <label>差分IoU（位置一致判定） <span id="iouVal">0.45</span></label>
        <input id="iouThr" type="range" min="0.2" max="0.9" step="0.05" value="0.45">
      </div>
      <div class="control">
        <label>サイズ差しきい値（面積相対差） <span id="sizeVal">0.50</span></label>
        <input id="sizeThr" type="range" min="0.1" max="0.9" step="0.05" value="0.50">
      </div>
      <div class="control">
        <label>OpenCV差分しきい値 <span id="cvThrVal">40</span></label>
        <input id="cvThr" type="range" min="20" max="80" step="2" value="40">
      </div>
      <div class="control">
        <label>最大表示幅（px） <span id="maxWVal">1024</span></label>
        <input id="maxW" type="range" min="640" max="1920" step="64" value="1024">
      </div>
    </div>

    <p class="small">AにあってBにない＝<b style="color:#ff8080">赤</b>、BにあってAにない＝<b style="color:#80a0ff">青</b>。OpenCV画素差分は<b style="color:#ff8080">赤</b>に重ねます。</p>
    <div class="row">
      <figure style="flex:1"><figcaption>画像Aプレビュー</figcaption><img id="imgA" alt=""></figure>
      <figure style="flex:1"><figcaption>画像Bプレビュー</figcaption><img id="imgB" alt=""></figure>
    </div>
  </section>

  <section class="card">
    <h2 style="margin:0 0 8px">結果（相違領域を色枠で表示）</h2>
    <canvas id="canvas" width="1024" height="768"></canvas>
    <p class="small">下地は<strong>画像A</strong>。YOLOの双方向差分＋OpenCV画素差分（大物体一致領域のマスク後）を重ねています。</p>
  </section>
</main>

<!-- ✅ 依存ライブラリ（CDN）。オフライン運用する場合は lib/ に同梱したファイルへ差し替え -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* === UI参照 === */
const els = {
  fileA: document.getElementById('fileA'),
  fileB: document.getElementById('fileB'),
  imgA: document.getElementById('imgA'),
  imgB: document.getElementById('imgB'),
  canvas: document.getElementById('canvas'),
  btnDetect: document.getElementById('btnDetect'),
  btnSaveJpg: document.getElementById('btnSaveJpg'),
  confThr: document.getElementById('confThr'),
  nmsThr: document.getElementById('nmsThr'),
  iouThr: document.getElementById('iouThr'),
  sizeThr: document.getElementById('sizeThr'),
  cvThr: document.getElementById('cvThr'),
  maxW: document.getElementById('maxW'),
  confVal: document.getElementById('confVal'),
  nmsVal: document.getElementById('nmsVal'),
  iouVal: document.getElementById('iouVal'),
  sizeVal: document.getElementById('sizeVal'),
  cvThrVal: document.getElementById('cvThrVal'),
  maxWVal: document.getElementById('maxWVal'),
};
let aReady=false, bReady=false;

/* === 画像読み込み（createObjectURL版。HEIC検知＆エラー処理付）=== */
els.fileA.addEventListener('change', e => loadViaObjectURL(e.target.files?.[0], els.imgA, () => aReady=true));
els.fileB.addEventListener('change', e => loadViaObjectURL(e.target.files?.[0], els.imgB, () => bReady=true));

function loadViaObjectURL(file, imgEl, onOk){
  if(!file){ alert('ファイルが選択されていません'); return; }
  const mime = (file.type||'').toLowerCase();
  if(!mime.startsWith('image/')){ alert('画像ファイルを選択してください（JPEG/PNG推奨）'); return; }
  if(mime.includes('heic') || mime.includes('heif')){
    alert('HEIC/HEIFはブラウザで表示できない場合があります。JPEG/PNGでお試しください。'); return;
  }
  const url = URL.createObjectURL(file);
  imgEl.onload = ()=>{ URL.revokeObjectURL(url); onOk&&onOk(); };
  imgEl.onerror = ()=>{ URL.revokeObjectURL(url); alert('画像の読み込みに失敗しました。ファイルが破損している可能性があります。'); };
  imgEl.src = url;
}

/* === しきい値表示 === */
function updateVals(){
  els.confVal.textContent = parseFloat(els.confThr.value).toFixed(2);
  els.nmsVal.textContent  = parseFloat(els.nmsThr.value).toFixed(2);
  els.iouVal.textContent  = parseFloat(els.iouThr.value).toFixed(2);
  els.sizeVal.textContent = parseFloat(els.sizeThr.value).toFixed(2);
  els.cvThrVal.textContent= parseInt(els.cvThr.value,10);
  els.maxWVal.textContent = parseInt(els.maxW.value,10);
}
['confThr','nmsThr','iouThr','sizeThr','cvThr','maxW'].forEach(id=>els[id].addEventListener('input',updateVals));
updateVals();

/* === YOLOv8 セッション＆OpenCV準備 === */
let yoloSession=null;
async function ensureYolo(){
  if(!yoloSession){
    // モデルは index.html と同じ階層に置く（並列）
    yoloSession = await ort.InferenceSession.create('./yolov8n.onnx', {
      executionProviders: ['wasm'], graphOptimizationLevel: 'all'
    });
    console.log('YOLOv8 ONNX loaded');
  }
}
function waitForCv(){
  return new Promise(resolve=>{
    if(window.__cvReady && window.cv && cv.Mat){ resolve(); return; }
    const t=setInterval(()=>{ if(window.__cvReady && window.cv && cv.Mat){ clearInterval(t); resolve(); } },50);
  });
}

/* === 前処理（letterbox 640x640）=== */
function letterbox(imgEl, newShape=640, color=[114,114,114]){
  const iw = imgEl.naturalWidth, ih = imgEl.naturalHeight;
  const r = Math.min(newShape/iw, newShape/ih);
  const nw = Math.round(iw*r), nh = Math.round(ih*r);
  const px = Math.round((newShape - nw)/2), py = Math.round((newShape - nh)/2);

  const c = document.createElement('canvas'); c.width=newShape; c.height=newShape;
  const ctx = c.getContext('2d');
  ctx.fillStyle = `rgb(${color[0]},${color[1]},${color[2]})`;
  ctx.fillRect(0,0,newShape,newShape);
  ctx.drawImage(imgEl, 0,0, iw,ih, px,py, nw,nh);
  return {canvas:c, ratio:r, padX:px, padY:py, origW:iw, origH:ih};
}
function toCHWFloat32(canvas){
  const ctx = canvas.getContext('2d');
  const {width:w,height:h} = canvas;
  const img = ctx.getImageData(0,0,w,h).data; // RGBA
  const size = w*h;
  const data = new Float32Array(3*size);
  for(let i=0, p=0;i<size;i++,p+=4){
    data[i]        = img[p]   / 255.0; // R
    data[i+size]   = img[p+1] / 255.0; // G
    data[i+2*size] = img[p+2] / 255.0; // B
  }
  return data;
}

/* === 推論・後処理 === */
// Ultralytics YOLOv8（640）出力想定: [1,84,8400] → flattenで [84,8400]
function decodeYOLOv8(outData, info, confThr=0.35, nmsIoU=0.45){
  const numPred = 8400, numCls = 80, stride = numPred;
  const boxes=[];
  for(let i=0;i<numPred;i++){
    const x = outData[0*stride+i], y = outData[1*stride+i];
    const w = outData[2*stride+i], h = outData[3*stride+i];
    const obj = outData[4*stride+i];
    let best=0, cid=0;
    for(let c=0;c<numCls;c++){
      const v = outData[(5+c)*stride + i];
      if(v>best){ best=v; cid=c; }
    }
    const conf = obj*best;
    if(conf < confThr) continue;

    // letterbox逆補正 → 元画像座標
    const cx = x - info.padX, cy = y - info.padY;
    const gx = cx/info.ratio,  gy = cy/info.ratio;
    const gw = w/info.ratio,   gh = h/info.ratio;
    const x1 = Math.max(0, gx - gw/2), y1 = Math.max(0, gy - gh/2);
    const x2 = Math.min(info.origW, gx + gw/2), y2 = Math.min(info.origH, gy + gh/2);
    boxes.push({x1,y1,x2,y2, conf, cls:cid});
  }
  // NMS
  boxes.sort((a,b)=>b.conf-a.conf);
  const picked=[];
  const iou = (a,b)=>{
    const xx1=Math.max(a.x1,b.x1), yy1=Math.max(a.y1,b.y1);
    const xx2=Math.min(a.x2,b.x2), yy2=Math.min(a.y2,b.y2);
    const w=Math.max(0,xx2-xx1), h=Math.max(0,yy2-yy1);
    const inter=w*h;
    const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
    const union=areaA+areaB-inter;
    return union>0 ? inter/union : 0;
  };
  boxes.forEach(b=>{
    let keep=true; for(const p of picked){ if(iou(b,p)>nmsIoU){ keep=false; break; } }
    if(keep) picked.push(b);
  });
  return picked;
}

/* 差分（双方向） */
function iouRect(a,b){
  const xx1=Math.max(a.x1,b.x1), yy1=Math.max(a.y1,b.y1);
  const xx2=Math.min(a.x2,b.x2), yy2=Math.min(a.y2,b.y2);
  const w=Math.max(0,xx2-xx1), h=Math.max(0,yy2-yy1);
  const inter=w*h;
  const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
  const union=areaA+areaB-inter;
  return union>0 ? inter/union : 0;
}
function diffOneWay(objsA, objsB, iouThr, sizeRatioThr){
  const diffs=[];
  objsA.forEach(a=>{
    const cand = objsB.filter(b=>b.cls===a.cls);
    let matched=false;
    for(const b of cand){
      const i = iouRect(a,b);
      const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
      const sizeRatio = Math.abs(areaA-areaB)/Math.max(areaA,areaB);
      if(i>=iouThr && sizeRatio<=sizeRatioThr){ matched=true; break; }
    }
    if(!matched) diffs.push(a);
  });
  return diffs;
}
function semanticDiffBoth(objsA, objsB, iouThr, sizeRatioThr){
  return { diffA: diffOneWay(objsA,objsB,iouThr,sizeRatioThr), diffB: diffOneWay(objsB,objsA,iouThr,sizeRatioThr) };
}

/* マスク（大物体） */
function buildMaskFromDetections(W,H, objs, origW, origH){
  const c=document.createElement('canvas'); c.width=W; c.height=H;
  const ctx=c.getContext('2d');
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle='#fff';
  const bigAreaThr=(W*H)*0.002; // 0.2%以上を「大物」
  objs.forEach(o=>{
    const w=(o.x2-o.x1), h=(o.y2-o.y1);
    if(w*h>=bigAreaThr){
      ctx.fillRect(o.x1*(W/origW), o.y1*(H/origH), w*(W/origW), h*(H/origH));
    }
  });
  return c;
}

/* OpenCV差分（非マスク領域） */
function cvDiffMasked(imgAEl, imgBEl, outCanvas, maskCanvas, thrVal){
  const W=outCanvas.width, H=outCanvas.height;
  const tmpA=document.createElement('canvas'), tmpB=document.createElement('canvas');
  tmpA.width=W; tmpA.height=H; tmpB.width=W; tmpB.height=H;
  tmpA.getContext('2d').drawImage(imgAEl,0,0,W,H);
  tmpB.getContext('2d').drawImage(imgBEl,0,0,W,H);

  const matA=cv.imread(tmpA), matB=cv.imread(tmpB);
  const gA=new cv.Mat(), gB=new cv.Mat();
  cv.cvtColor(matA,gA,cv.COLOR_RGBA2GRAY);
  cv.cvtColor(matB,gB,cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gA,gA,new cv.Size(5,5),0);
  cv.GaussianBlur(gB,gB,new cv.Size(5,5),0);

  const diff=new cv.Mat(); cv.absdiff(gA,gB,diff); cv.normalize(diff,diff,0,255,cv.NORM_MINMAX);

  const maskMat=cv.imread(maskCanvas);
  const maskGray=new cv.Mat(); cv.cvtColor(maskMat,maskGray,cv.COLOR_RGBA2GRAY);
  const invMask=new cv.Mat(); cv.threshold(maskGray,invMask,128,255,cv.THRESH_BINARY_INV);

  const masked=new cv.Mat(); cv.bitwise_and(diff,invMask,masked);

  const bw=new cv.Mat();
  cv.threshold(masked,bw,thrVal,255,cv.THRESH_BINARY);
  const kernel=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(3,3));
  cv.morphologyEx(bw,bw,cv.MORPH_OPEN,kernel);
  cv.dilate(bw,bw,kernel);

  const ctx=outCanvas.getContext('2d');
  const contours=new cv.MatVector(); const hierarchy=new cv.Mat();
  cv.findContours(bw,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  ctx.strokeStyle='rgba(255,64,64,0.98)'; ctx.fillStyle='rgba(255,64,64,0.18)';
  ctx.lineWidth=Math.max(2,Math.floor(W/512));
  for(let i=0;i<contours.size();i++){
    const r=cv.boundingRect(contours.get(i));
    if(r.width*r.height<150) continue;
    ctx.fillRect(r.x,r.y,r.width,r.height);
    ctx.strokeRect(r.x,r.y,r.width,r.height);
  }
  [matA,matB,gA,gB,diff,maskMat,maskGray,invMask,masked,bw,contours,hierarchy,kernel].forEach(m=>m.delete());
}

/* 描画 */
function drawHybrid(baseImgEl, otherImgEl, detA, detB, diffA, diffB){
  const ctx=els.canvas.getContext('2d');
  const MAX_W=parseInt(els.maxW.value,10);
  const ratio=Math.min(1, MAX_W/baseImgEl.naturalWidth);
  const W=Math.round(baseImgEl.naturalWidth*ratio);
  const H=Math.round(baseImgEl.naturalHeight*ratio);
  els.canvas.width=W; els.canvas.height=H;

  ctx.drawImage(baseImgEl,0,0,W,H);

  const sx=W/baseImgEl.naturalWidth, sy=H/baseImgEl.naturalHeight;

  // A\B（赤）
  ctx.strokeStyle='rgba(255,64,64,0.98)'; ctx.fillStyle='rgba(255,64,64,0.18)';
  ctx.lineWidth=Math.max(2,Math.floor(W/512));
  diffA.forEach(d=>{
    const x=d.x1*sx, y=d.y1*sy, w=(d.x2-d.x1)*sx, h=(d.y2-d.y1)*sy;
    ctx.fillRect(x,y,w,h); ctx.strokeRect(x,y,w,h);
  });

  // B\A（青）
  ctx.strokeStyle='rgba(64,128,255,0.98)'; ctx.fillStyle='rgba(64,128,255,0.18)';
  diffB.forEach(d=>{
    const x=d.x1*sx, y=d.y1*sy, w=(d.x2-d.x1)*sx, h=(d.y2-d.y1)*sy;
    ctx.fillRect(x,y,w,h); ctx.strokeRect(x,y,w,h);
  });

  // 大物体マスク → OpenCV画素差重ね
  const maskA = buildMaskFromDetections(W,H, detA, baseImgEl.naturalWidth, baseImgEl.naturalHeight);
  cvDiffMasked(baseImgEl, otherImgEl, els.canvas, maskA, parseInt(els.cvThr.value,10));
}

/* 実行・保存 */
els.btnDetect.addEventListener('click', async ()=>{
  if(!aReady || !bReady){ alert('画像A・画像Bを選択してください'); return; }
  els.btnDetect.disabled=true; els.btnDetect.textContent='推論中…';
  try{
    await ensureYolo();
    await waitForCv();

    // 前処理
    const lbA = letterbox(els.imgA, 640);
    const lbB = letterbox(els.imgB, 640);
    const inputA = new ort.Tensor('float32', toCHWFloat32(lbA.canvas), [1,3,640,640]);
    const inputB = new ort.Tensor('float32', toCHWFloat32(lbB.canvas), [1,3,640,640]);

    // 入出力名を取得して正しく渡す（重要）
    const inName = yoloSession.inputNames[0];
    const outName = yoloSession.outputNames[0];

    const confThr = parseFloat(els.confThr.value);
    const nmsIoU  = parseFloat(els.nmsThr.value);

    // 推論（A/B）
    const outA = await yoloSession.run({ [inName]: inputA });
    const outB = await yoloSession.run({ [inName]: inputB });
    const detA = decodeYOLOv8(outA[outName].data, {ratio:lbA.ratio, padX:lbA.padX, padY:lbA.padY, origW:lbA.origW, origH:lbA.origH}, confThr, nmsIoU);
    const detB = decodeYOLOv8(outB[outName].data, {ratio:lbB.ratio, padX:lbB.padX, padY:lbB.padY, origW:lbB.origW, origH:lbB.origH}, confThr, nmsIoU);

    // 差分（双方向）
    const {diffA, diffB} = semanticDiffBoth(detA, detB, parseFloat(els.iouThr.value), parseFloat(els.sizeThr.value));

    // 描画
    drawHybrid(els.imgA, els.imgB, detA, detB, diffA, diffB);

    els.btnSaveJpg.disabled=true;
    setTimeout(()=>{ els.btnSaveJpg.disabled=false; }, 120);
  }catch(e){
    console.error(e);
    alert('推論/差分でエラー：'+ e.message);
  }finally{
    els.btnDetect.disabled=false; els.btnDetect.textContent='差分を検出';
  }
});
els.btnSaveJpg.addEventListener('click', ()=>{
  const dataUrl = els.canvas.toDataURL('image/jpeg', 0.85);
  const a=document.createElement('a');
  a.href=dataUrl;
  a.download=`差分結果_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.jpg`;
  a.click();
});
</script>
</body>
</html>
