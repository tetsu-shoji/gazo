
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>差分検出（画像＋コメント出力／YOLOv8＋OpenCV）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{ --bg:#0b132b; --panel:#1c2541; --text:#eaeaea; --accent:#5bc0be; }
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,"Segoe UI",sans-serif;}
    header{padding:14px 18px;background:var(--panel);border-bottom:1px solid #2f3b66;}
    header h1{margin:0;font-size:18px}
    main{padding:16px;display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .card{background:var(--panel);border:1px solid #2f3b66;border-radius:10px;padding:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label.btn{background:#3a506b;color:#d6eaff;padding:10px 12px;border-radius:8px;cursor:pointer}
    input[type=file]{display:none}
    canvas, img, video{max-width:100%;height:auto;border-radius:6px;border:1px solid #2f3b66;background:#000}
    img{display:block}
    video{display:none}
    .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px}
    .control{background:#162447;border:1px solid #2f3b66;border-radius:8px;padding:8px}
    .control label{display:block;font-size:12px;margin-bottom:6px;opacity:.85}
    .btn{background:var(--accent);color:#012a36;border:none;border-radius:8px;padding:10px 12px;font-weight:700;cursor:pointer}
    .btn.secondary{background:#3a506b;color:#d6eaff}
    .small{font-size:12px;opacity:.8}
    @media (max-width:1100px){ main{grid-template-columns:1fr} }
    .toggle{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .legend{font-size:12px;opacity:.8;margin-top:6px}
    /* コメントパネル */
    .comment{background:#0d1b2a;border:1px solid #2f3b66;border-radius:10px;padding:10px;margin-top:10px}
    .comment h3{margin:0 0 6px;font-size:14px}
    .comment ol{margin:6px 0 0 18px}
    .comment li{margin:4px 0}
    .comment .badge{display:inline-block;background:#5bc0be;color:#012a36;border-radius:6px;padding:2px 6px;margin-right:6px;font-weight:700}
    .comment .tag{display:inline-block;background:#3a506b;color:#d6eaff;border-radius:6px;padding:2px 6px;margin-left:6px;font-size:12px}
  </style>
  <!-- OpenCV.js 初期化通知 -->
  <script>
    window.__cvReady = false;
    window.Module = { onRuntimeInitialized(){ window.__cvReady = true; console.log('OpenCV.js ready'); } };
  </script>
</head>
<body>
<header><h1>差分検出（画像＋コメント出力／YOLOv8＋OpenCV）</h1></header>

<main>
  <!-- 左：入力 -->
  <section class="card">
    <h2 style="margin:0 0 8px">入力画像／カメラ撮影</h2>
    <div class="row">
      <label class="btn">画像Aを選択<input id="fileA" type="file" accept="image/*" /></label>
      <label class="btn">画像Bを選択<input id="fileB" type="file" accept="image/*" /></label>
      <button id="btnDetect" class="btn">差分を検出</button>
      <button id="btnSaveJpg" class="btn secondary" disabled>JPEGで保存</button>
      <button id="btnCopyJson" class="btn secondary" disabled>差分JSONをコピー</button>
    </div>

    <!-- カメラ操作 -->
    <div class="row">
      <button id="btnCamStart" class="btn secondary">カメラ起動</button>
      <button id="btnCamShotA" class="btn secondary" disabled>撮影Aに取り込み</button>
      <button id="btnCamShotB" class="btn secondary" disabled>撮影Bに取り込み</button>
      <button id="btnCamStop"  class="btn secondary" disabled>カメラ停止</button>
    </div>
    <video id="videoPreview" playsinline></video>

    <!-- 基準・表現・補正 -->
    <div class="toggle" style="margin-top:8px">
      <span>基準画像：</span>
      <label><input type="radio" name="base" id="baseA" value="A" checked> A（Bに追加を検出）</label>
      <label><input type="radio" name="base" id="baseB" value="B"> B（Aに追加を検出）</label>
      <span style="margin-left:12px">表現：</span>
      <label><input type="radio" name="render" id="modeBoxes" value="boxes" checked> 枠（少数）</label>
      <label><input type="radio" name="render" id="modeHeat" value="heat"> ヒートマップ</label>
      <label style="margin-left:12px"><input type="checkbox" id="chkAlign"> 自動位置補正（AFFINE）</label>
    </div>
    <p class="legend">
      ・A基準：<span style="color:#80a0ff">青枠</span>／B基準：<span style="color:#ffa040">橙枠</span>。  
      ・位置補正ONで、撮影時のズレを平行移動＋回転・スケールで補正。
    </p>

    <!-- しきい値群（おすすめデフォルト） -->
    <div class="controls">
      <div class="control"><label>YOLO 信頼度しきい値 <span id="confVal">0.35</span></label>
        <input id="confThr" type="range" min="0.10" max="0.90" step="0.05" value="0.35">
      </div>
      <div class="control"><label>YOLO NMS IoU <span id="nmsVal">0.45</span></label>
        <input id="nmsThr" type="range" min="0.20" max="0.90" step="0.05" value="0.45">
      </div>
      <div class="control"><label>差分IoU（目安） <span id="iouVal">0.45</span></label>
        <input id="iouThr" type="range" min="0.20" max="0.90" step="0.05" value="0.45">
      </div>
      <div class="control"><label>サイズ差（面積相対差） <span id="sizeVal">0.50</span></label>
        <input id="sizeThr" type="range" min="0.10" max="0.90" step="0.05" value="0.50">
      </div>
      <div class="control"><label>OpenCV差分しきい値 <span id="cvThrVal">0</span></label>
        <input id="cvThr" type="range" min="0" max="80" step="2" value="0"><!-- 0=Otsu -->
      </div>
      <div class="control"><label>最小差分面積（%） <span id="minAreaVal">0.10</span></label>
        <input id="minArea" type="range" min="0.02" max="0.50" step="0.02" value="0.10">
      </div>
      <div class="control"><label>枠数の上限（Top‑K） <span id="topKVal">5</span></label>
        <input id="topK" type="range" min="1" max="12" step="1" value="5">
      </div>
      <div class="control"><label>最大表示幅（px） <span id="maxWVal">1024</span></label>
        <input id="maxW" type="range" min="640" max="1920" step="64" value="1024">
      </div>
      <div class="control"><label>大物体マスク閾（%） <span id="maskPctVal">2.0</span></label>
        <input id="maskPct" type="range" min="0.0" max="5.0" step="0.2" value="2.0">
      </div>
    </div>

    <p class="small">※ HEIC/HEIFはブラウザで表示できない場合があります。JPEG/PNGでお試しください。</p>
    <div class="row">
      <figure style="flex:1"><figcaption>画像Aプレビュー</figcaption><img id="imgA" alt=""></figure>
      <figure style="flex:1"><figcaption>画像Bプレビュー</figcaption><img id="imgB" alt=""></figure>
    </div>
  </section>

  <!-- 右：結果 ＋ コメント -->
  <section class="card">
    <h2 style="margin:0 0 8px">結果（差分強調表示）</h2>
    <canvas id="canvas" width="1024" height="768"></canvas>
    <p class="small">下地は<strong>基準画像</strong>。枠は少数化（NMS＋面積しきい値＋Top‑K）、ヒートは差分領域の濃淡で強調、Otsuで露出差への耐性を確保。</p>

    <div class="comment">
      <h3>差分コメント</h3>
      <div id="summaryHdr" class="small" style="opacity:.85"></div>
      <h4 style="margin:10px 0 6px">追加</h4>
      <ol id="listAdded"></ol>
      <h4 style="margin:10px 0 6px">削除</h4>
      <ol id="listRemoved"></ol>
      <h4 style="margin:10px 0 6px">移動・サイズ変化</h4>
      <ol id="listMoved"></ol>
    </div>
  </section>
</main>

<!-- 依存ライブラリ -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* === UI参照 === */
const els = {
  fileA: document.getElementById('fileA'),
  fileB: document.getElementById('fileB'),
  imgA: document.getElementById('imgA'),
  imgB: document.getElementById('imgB'),
  canvas: document.getElementById('canvas'),
  btnDetect: document.getElementById('btnDetect'),
  btnSaveJpg: document.getElementById('btnSaveJpg'),
  btnCopyJson: document.getElementById('btnCopyJson'),
  baseA: document.getElementById('baseA'),
  baseB: document.getElementById('baseB'),
  modeBoxes: document.getElementById('modeBoxes'),
  modeHeat:  document.getElementById('modeHeat'),
  chkAlign:  document.getElementById('chkAlign'),
  confThr: document.getElementById('confThr'),
  nmsThr: document.getElementById('nmsThr'),
  iouThr: document.getElementById('iouThr'),
  sizeThr: document.getElementById('sizeThr'),
  cvThr: document.getElementById('cvThr'),
  minArea: document.getElementById('minArea'),
  topK: document.getElementById('topK'),
  maxW: document.getElementById('maxW'),
  maskPct: document.getElementById('maskPct'),
  confVal: document.getElementById('confVal'),
  nmsVal: document.getElementById('nmsVal'),
  iouVal: document.getElementById('iouVal'),
  sizeVal: document.getElementById('sizeVal'),
  cvThrVal: document.getElementById('cvThrVal'),
  minAreaVal: document.getElementById('minAreaVal'),
  topKVal: document.getElementById('topKVal'),
  maxWVal: document.getElementById('maxWVal'),
  maskPctVal: document.getElementById('maskPctVal'),
  btnCamStart: document.getElementById('btnCamStart'),
  btnCamShotA: document.getElementById('btnCamShotA'),
  btnCamShotB: document.getElementById('btnCamShotB'),
  btnCamStop:  document.getElementById('btnCamStop'),
  video: document.getElementById('videoPreview'),
  // コメントDOM
  listAdded: document.getElementById('listAdded'),
  listRemoved: document.getElementById('listRemoved'),
  listMoved: document.getElementById('listMoved'),
  summaryHdr: document.getElementById('summaryHdr'),
};
let aReady=false, bReady=false;
let lastDiffJson=null;

/* === 画像読み込み === */
els.fileA.addEventListener('change', e => loadViaObjectURL(e.target.files?.[0], els.imgA, () => aReady=true));
els.fileB.addEventListener('change', e => loadViaObjectURL(e.target.files?.[0], els.imgB, () => bReady=true));
function loadViaObjectURL(file, imgEl, onOk){
  if(!file){ alert('ファイルが選択されていません'); return; }
  const mime = (file.type||'').toLowerCase();
  if(!mime.startsWith('image/')){ alert('画像ファイルを選択してください（JPEG/PNG推奨）'); return; }
  if(mime.includes('heic') || mime.includes('heif')){
    alert('HEIC/HEIFは表示できない場合があります。JPEG/PNGでお試しください。'); return;
  }
  const url = URL.createObjectURL(file);
  imgEl.onload = ()=>{ URL.revokeObjectURL(url); onOk&&onOk(); };
  imgEl.onerror = ()=>{ URL.revokeObjectURL(url); alert('画像の読み込みに失敗しました。'); };
  imgEl.src = url;
}

/* === しきい値表示 === */
function updateVals(){
  els.confVal.textContent = parseFloat(els.confThr.value).toFixed(2);
  els.nmsVal.textContent  = parseFloat(els.nmsThr.value).toFixed(2);
  els.iouVal.textContent  = parseFloat(els.iouThr.value).toFixed(2);
  els.sizeVal.textContent = parseFloat(els.sizeThr.value).toFixed(2);
  els.cvThrVal.textContent= parseInt(els.cvThr.value,10);
  els.minAreaVal.textContent= parseFloat(els.minArea.value).toFixed(2);
  els.topKVal.textContent    = parseInt(els.topK.value,10);
  els.maxWVal.textContent    = parseInt(els.maxW.value,10);
  els.maskPctVal.textContent = parseFloat(els.maskPct.value).toFixed(1);
}
['confThr','nmsThr','iouThr','sizeThr','cvThr','minArea','topK','maxW','maskPct']
  .forEach(id=>els[id].addEventListener('input',updateVals));
updateVals();

/* === カメラ起動／撮影 === */
let camStream=null;
els.btnCamStart.addEventListener('click', async ()=>{
  try{
    camStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
    els.video.srcObject = camStream; els.video.style.display='block'; await els.video.play();
    els.btnCamShotA.disabled=false; els.btnCamShotB.disabled=false; els.btnCamStop.disabled=false;
  }catch(e){ alert('カメラ起動に失敗しました：'+e.message); }
});
els.btnCamStop.addEventListener('click', ()=>{
  try{ camStream?.getTracks()?.forEach(t=>t.stop()); }catch(_){}
  els.video.srcObject=null; els.video.style.display='none';
  els.btnCamShotA.disabled=true; els.btnCamShotB.disabled=true; els.btnCamStop.disabled=true;
});
els.btnCamShotA.addEventListener('click', ()=> captureFrameToImage(els.video, els.imgA, ()=>aReady=true));
els.btnCamShotB.addEventListener('click', ()=> captureFrameToImage(els.video, els.imgB, ()=>bReady=true));
function captureFrameToImage(videoEl, targetImg, onOk){
  const c=document.createElement('canvas');
  const w=videoEl.videoWidth, h=videoEl.videoHeight;
  c.width=w; c.height=h;
  c.getContext('2d').drawImage(videoEl,0,0,w,h);
  targetImg.src=c.toDataURL('image/jpeg',0.92);
  targetImg.onload=()=>onOk&&onOk();
}

/* === YOLOv8 セッション＆OpenCV準備 === */
let yoloSession=null;
async function ensureYolo(){
  if(!yoloSession){
    yoloSession = await ort.InferenceSession.create('./yolov8n.onnx', {
      executionProviders: ['wasm'], graphOptimizationLevel: 'all'
    });
    console.log('YOLOv8 ONNX loaded');
  }
}
function waitForCv(){
  return new Promise(resolve=>{
    if(window.__cvReady && window.cv && cv.Mat){ resolve(); return; }
    const t=setInterval(()=>{ if(window.__cvReady && window.cv && cv.Mat){ clearInterval(t); resolve(); } },50);
  });
}

/* === 前処理 === */
function letterbox(imgEl, newShape=640, color=[114,114,114]){
  const iw = imgEl.naturalWidth, ih = imgEl.naturalHeight;
  const r = Math.min(newShape/iw, newShape/ih);
  const nw = Math.round(iw*r), nh = Math.round(ih*r);
  const px = Math.round((newShape - nw)/2), py = Math.round((newShape - nh)/2);
  const c = document.createElement('canvas'); c.width=newShape; c.height=newShape;
  const ctx = c.getContext('2d');
  ctx.fillStyle = `rgb(${color[0]},${color[1]},${color[2]})`;
  ctx.fillRect(0,0,newShape,newShape);
  ctx.drawImage(imgEl, 0,0, iw,ih, px,py, nw,nh);
  return {canvas:c, ratio:r, padX:px, padY:py, origW:iw, origH:ih};
}
function toCHWFloat32(canvas){
  const ctx = canvas.getContext('2d');
  const {width:w,height:h} = canvas;
  const img = ctx.getImageData(0,0,w,h).data; // RGBA
  const size = w*h;
  const data = new Float32Array(3*size);
  for(let i=0, p=0;i<size;i++,p+=4){
    data[i]        = img[p]   / 255.0; // R
    data[i+size]   = img[p+1] / 255.0; // G
    data[i+2*size] = img[p+2] / 255.0; // B
  }
  return data;
}

/* === COCO80 クラス名（YOLOv8n標準） === */
const COCO80 = [
 'person','bicycle','car','motorcycle','airplane','bus','train','truck','boat','traffic light',
 'fire hydrant','stop sign','parking meter','bench','bird','cat','dog','horse','sheep','cow','elephant','bear','zebra','giraffe',
 'backpack','umbrella','handbag','tie','suitcase','frisbee','skis','snowboard','sports ball','kite','baseball bat','baseball glove',
 'skateboard','surfboard','tennis racket','bottle','wine glass','cup','fork','knife','spoon','bowl','banana','apple','sandwich',
 'orange','broccoli','carrot','hot dog','pizza','donut','cake','chair','couch','potted plant','bed','dining table','toilet','tv',
 'laptop','mouse','remote','keyboard','cell phone','microwave','oven','toaster','sink','refrigerator','book','clock','vase',
 'scissors','teddy bear','hair drier','toothbrush'
];

/* === 安全なシグモイド === */
const sigmoid = x => 1 / (1 + Math.exp(-x));

/* === 推論・後処理（形状/活性化差吸収） === */
function robustDecodeYOLOv8(tensor, info, confThr=0.35, nmsIoU=0.45){
  const dims = tensor.dims || [];
  const data = tensor.data;
  let N=0, clsDim=80, stride=0, layout='84xN';
  if (dims.length === 3) {
    if (dims[1] === 84) { N = dims[2]; stride = N; layout = '84xN'; }
    else if (dims[2] === 84) { N = dims[1]; stride = 84; layout = 'Nx84'; }
  } else { N = 8400; stride = N; layout = '84xN'; }

  const boxes=[];
  for (let i=0;i<N;i++){
    let x,y,w,h,obj,startClsIdx;
    if (layout === '84xN'){
      x   = data[0*stride + i];
      y   = data[1*stride + i];
      w   = data[2*stride + i];
      h   = data[3*stride + i];
      obj = sigmoid(data[4*stride + i]);
      startClsIdx = 5*stride + i;
    }else{
      const base = i*stride;
      x   = data[base + 0];
      y   = data[base + 1];
      w   = data[base + 2];
      h   = data[base + 3];
      obj = sigmoid(data[base + 4]);
      startClsIdx = base + 5;
    }
    let best=0, cid=0;
    for (let c=0;c<clsDim;c++){
      const v = sigmoid(data[startClsIdx + c]);
      if (v>best){ best=v; cid=c; }
    }
    const conf = obj * best;
    if (conf < confThr) continue;

    const cx = x - info.padX, cy = y - info.padY;
    const gx = cx/info.ratio,  gy = cy/info.ratio;
    const gw = w/info.ratio,   gh = h/info.ratio;
    const x1 = Math.max(0, gx - gw/2), y1 = Math.max(0, gy - gh/2);
    const x2 = Math.min(info.origW, gx + gw/2), y2 = Math.min(info.origH, gy + gh/2);
    boxes.push({x1,y1,x2,y2, conf, cls:cid, name:COCO80[cid]||'未定義'});
  }
  boxes.sort((a,b)=> b.conf - a.conf);
  const picked=[];
  const iou=(a,b)=>{
    const xx1=Math.max(a.x1,b.x1), yy1=Math.max(a.y1,b.y1);
    const xx2=Math.min(a.x2,b.x2), yy2=Math.min(a.y2,b.y2);
    const w=Math.max(0,xx2-xx1), h=Math.max(0,yy2-yy1);
    const inter=w*h;
    const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
    const union=areaA+areaB-inter;
    return union>0 ? inter/union : 0;
  };
  boxes.forEach(b=>{
    let keep=true; for(const p of picked){ if(iou(b,p)>nmsIoU){ keep=false; break; } }
    if(keep) picked.push(b);
  });
  return picked;
}

/* === 差分（複合コスト） === */
function iouRect(a,b){
  const xx1=Math.max(a.x1,b.x1), yy1=Math.max(a.y1,b.y1);
  const xx2=Math.min(a.x2,b.x2), yy2=Math.min(a.y2,b.y2);
  const w=Math.max(0,xx2-xx1), h=Math.max(0,yy2-yy1);
  const inter=w*h;
  const areaA=(a.x2-a.x1)*(a.y2-a.y1), areaB=(b.x2-b.x1)*(b.y2-b.y1);
  const union=areaA+areaB-inter;
  return union>0 ? inter/union : 0;
}
function center(a){ return {cx:(a.x1+a.x2)/2, cy:(a.y1+a.y2)/2}; }
function area(b){ return Math.max(1,(b.x2-b.x1)*(b.y2-b.y1)); }
function pairwiseCost(a,b){
  const i = iouRect(a,b);
  const ca=center(a), cb=center(b);
  const d = Math.hypot(ca.cx-cb.cx, ca.cy-cb.cy);
  const s = Math.abs(area(a)-area(b))/Math.max(area(a),area(b));
  const classPenalty = (a.cls===b.cls) ? 0 : 0.15;
  return (1-i)*0.65 + (d/(Math.sqrt(area(a))+Math.sqrt(area(b))))*0.25 + s*0.10 + classPenalty;
}
function greedyAssign(A,B,costThr=0.45){
  const usedB=new Set(); const matches=[];
  for(const a of A){
    let best={j:-1,cost:1e9};
    for(let j=0;j<B.length;j++){
      if(usedB.has(j)) continue;
      const c=pairwiseCost(a,B[j]);
      if(c<best.cost) best={j, cost:c};
    }
    if(best.j>=0 && best.cost<=costThr){ usedB.add(best.j); matches.push([a,B[best.j],best.cost]); }
  }
  const unmatchedA = A.filter(a => !matches.some(m=>m[0]===a));
  const unmatchedB = B.filter((_,j)=> !usedB.has(j));
  return {matches, unmatchedA, unmatchedB};
}

/* === 差分枠ユーティリティ === */
function nmsDiff(boxes, iouThr=0.3){
  const iou=(a,b)=>{
    const xx1=Math.max(a.x1,b.x1), yy1=Math.max(a.y1,b.y1);
    const xx2=Math.min(a.x2,b.x2), yy2=Math.min(a.y2,b.y2);
    const w=Math.max(0,xx2-xx1), h=Math.max(0,yy2-yy1);
    const inter=w*h;
    const areaA=(a.x2-a.x1)*(a.y2-a.y1);
    const areaB=(b.x2-b.x1)*(b.y2-b.y1);
    const union=areaA+areaB-inter;
    return union>0 ? inter/union : 0;
  };
  const sorted=boxes.slice().sort((a,b)=> (b.conf||0)-(a.conf||0));
  const picked=[];
  sorted.forEach(b=>{
    let keep=true;
    for(const p of picked){ if(iou(b,p)>iouThr){ keep=false; break; } }
    if(keep) picked.push(b);
  });
  return picked;
}
function filterByArea(boxes, minArea){ return boxes.filter(b => area(b) >= minArea); }
function topKByArea(boxes, k){ return boxes.slice().sort((a,b)=> area(b)-area(a)).slice(0,k); }

/* === マスク（基準側の大物体） === */
function buildMaskFromDetections(W,H, objs, origW, origH){
  const c=document.createElement('canvas'); c.width=W; c.height=H;
  const ctx=c.getContext('2d');
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle='#fff';
  const pct = Math.max(0, parseFloat(els.maskPct.value)) / 100.0;
  const bigAreaThr = (W*H) * pct;
  objs.forEach(o=>{
    const w=(o.x2-o.x1), h=(o.y2-o.y1);
    if(w*h >= bigAreaThr){
      ctx.fillRect(o.x1*(W/origW), o.y1*(H/origH), w*(W/origW), h*(H/origH));
    }
  });
  return c;
}

/* === 位置補正（AFFINE→TRANSLATION） === */
function alignOtherToBaseCanvasAffine(baseImgEl, otherImgEl, W, H){
  const baseC=document.createElement('canvas'), otherC=document.createElement('canvas');
  baseC.width=W; baseC.height=H; otherC.width=W; otherC.height=H;
  baseC.getContext('2d').drawImage(baseImgEl,0,0,W,H);
  otherC.getContext('2d').drawImage(otherImgEl,0,0,W,H);
  try{
    const A=cv.imread(baseC), B=cv.imread(otherC);
    const gA=new cv.Mat(), gB=new cv.Mat();
    cv.cvtColor(A,gA,cv.COLOR_RGBA2GRAY);
    cv.cvtColor(B,gB,cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gA,gA,new cv.Size(3,3),0);
    cv.GaussianBlur(gB,gB,new cv.Size(3,3),0);
    const warp = cv.Mat.eye(2,3,cv.CV_32F);
    const criteria = new cv.TermCriteria(cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, 100, 1e-6);
    try{ cv.findTransformECC(gA, gB, warp, cv.MOTION_AFFINE, criteria); }
    catch(_){ cv.findTransformECC(gA, gB, warp, cv.MOTION_TRANSLATION, criteria); }
    const warped = new cv.Mat();
    cv.warpAffine(B, warped, warp, new cv.Size(W,H), cv.INTER_LINEAR, cv.BORDER_REFLECT);
    cv.imshow(otherC, warped);
    [A,B,gA,gB,warp,warped].forEach(m=>m.delete());
    return otherC;
  }catch(e){
    console.warn('位置補正失敗：', e);
    return otherC;
  }
}

/* === ヒート：Lab-L＋Otsu === */
function cvDiffHeatBetter(baseImgEl, otherCanvas, outCanvas, maskCanvas, thrVal){
  const W=outCanvas.width, H=outCanvas.height;
  const tmpA=document.createElement('canvas'); tmpA.width=W; tmpA.height=H;
  tmpA.getContext('2d').drawImage(baseImgEl,0,0,W,H);
  const matA=cv.imread(tmpA), matB=cv.imread(otherCanvas);
  const labA=new cv.Mat(), labB=new cv.Mat();
  cv.cvtColor(matA,labA,cv.COLOR_RGBA2RGB);
  cv.cvtColor(matB,labB,cv.COLOR_RGBA2RGB);
  cv.cvtColor(labA,labA,cv.COLOR_RGB2Lab);
  cv.cvtColor(labB,labB,cv.COLOR_RGB2Lab);
  const mvA=new cv.MatVector(), mvB=new cv.MatVector();
  cv.split(labA,mvA); cv.split(labB,mvB);
  const LA=mvA.get(0), LB=mvB.get(0);
  const diff=new cv.Mat(); cv.absdiff(LA,LB,diff);
  cv.GaussianBlur(diff,diff,new cv.Size(5,5),0);
  const maskMat=cv.imread(maskCanvas);
  const maskGray=new cv.Mat(); cv.cvtColor(maskMat,maskGray,cv.COLOR_RGBA2GRAY);
  const invMask=new cv.Mat(); cv.threshold(maskGray,invMask,128,255,cv.THRESH_BINARY_INV);
  const masked=new cv.Mat(); cv.bitwise_and(diff,invMask,masked);
  const bw=new cv.Mat();
  if(thrVal<=0){ cv.threshold(masked,bw,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU); }
  else { cv.threshold(masked,bw,thrVal,255,cv.THRESH_BINARY); }
  const heat=new cv.Mat(); cv.applyColorMap(bw, heat, cv.COLORMAP_TURBO);
  const ctx=outCanvas.getContext('2d'); ctx.save(); ctx.globalAlpha=0.35;
  const heatCanvas=document.createElement('canvas'); heatCanvas.width=W; heatCanvas.height=H;
  cv.imshow(heatCanvas, heat); ctx.drawImage(heatCanvas,0,0); ctx.restore();
  [matA,matB,labA,labB,mvA,mvB,LA,LB,diff,maskMat,maskGray,invMask,masked,bw,heat].forEach(m=>{ try{ m.delete(); }catch(_){ }});
  return true;
}

/* === バッジ・番号描画 === */
function drawBadge(ctx, text, ok=true){
  const W=ctx.canvas.width;
  ctx.save();
  ctx.font = `${Math.max(16, Math.floor(W/48))}px system-ui`;
  const pad=10, txtH = Math.max(28, Math.floor(W/32));
  const txtW = ctx.measureText(text).width + pad*2;
  ctx.fillStyle = ok ? 'rgba(46,204,113,0.9)' : 'rgba(231,76,60,0.9)';
  ctx.fillRect(pad, pad, txtW, txtH);
  ctx.strokeStyle='rgba(0,0,0,0.3)'; ctx.lineWidth=2;
  ctx.strokeRect(pad, pad, txtW, txtH);
  ctx.fillStyle='#fff'; ctx.fillText(text, pad+6, pad+txtH*0.7);
  ctx.restore();
}
function drawNumberTag(ctx, x, y, idx, color='rgba(64,128,255,0.98)'){
  ctx.save();
  ctx.fillStyle=color; ctx.strokeStyle='#000'; ctx.lineWidth=1.5;
  const r=Math.max(10, Math.floor(ctx.canvas.width/96));
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.fillStyle='#fff'; ctx.font=`${Math.max(12, Math.floor(ctx.canvas.width/64))}px system-ui`;
  const t=String(idx); const m=ctx.measureText(t);
  ctx.fillText(t, x - m.width/2, y + r*0.35);
  ctx.restore();
}

/* === コメント生成 === */
function posWord(xc,yc,W,H){
  const xr=xc/W, yr=yc/H;
  const h = xr<0.33 ? '左' : xr<0.66 ? '中央' : '右';
  const v = yr<0.33 ? '上' : yr<0.66 ? '中' : '下';
  return `${v}${h}`;
}
function pct(n){ return (n*100).toFixed(1); }

function makeCommentItems(base, W, H, added, removed, matches){
  // matches: [a,b,cost]
  const moveItems=[];
  const sizeThr = parseFloat(els.sizeThr.value);  // 面積相対差を「変化」とみなす
  matches.forEach(([a,b,cost],i)=>{
    const ca=center(a), cb=center(b);
    const dpx = Math.hypot(ca.cx-cb.cx, ca.cy-cb.cy);
    const sratio = Math.abs(area(a)-area(b))/Math.max(area(a),area(b));
    if (dpx>Math.max(W,H)*0.015 || sratio>sizeThr){ // 位置差1.5%超またはサイズ差しきい値超
      const pos = posWord(cb.cx, cb.cy, W, H);
      moveItems.push({
        id:i+1, kind:'moved', name:b.name||'物体', pos,
        deltaPx:Math.round(dpx), sizeChange:pct(sratio), iou:pct(iouRect(a,b))
      });
    }
  });

  function toItem(b, idx, kind){
    const c=center(b);
    const pos=posWord(c.cx, c.cy, W, H);
    const ar=area(b)/(W*H);
    return {
      id:idx, kind, name:b.name||'物体',
      pos, areaPct:pct(ar), box:[Math.round(b.x1),Math.round(b.y1),Math.round(b.x2),Math.round(b.y2)]
    };
  }
  const addItems = added.map((b,i)=> toItem(b, i+1, 'added'));
  const remItems = removed.map((b,i)=> toItem(b, i+1, 'removed'));
  return {addItems, remItems, moveItems};
}

function renderCommentPanel(base, counts, items){
  const hdr = `基準：${base}　追加:${counts.add}／削除:${counts.rem}／移動・サイズ:${counts.mov}`;
  els.summaryHdr.textContent = hdr;
  function fillList(ul, arr, tagColor){
    ul.innerHTML='';
    arr.forEach(it=>{
      const li=document.createElement('li');
      li.innerHTML = `<span class="badge">${it.id}</span>${it.name}（${it.pos}）` +
                     (it.areaPct? `<span class="tag" style="background:${tagColor}">面積比:${it.areaPct}%</span>`:'') +
                     (it.sizeChange? `<span class="tag" style="background:${tagColor}">サイズ差:${it.sizeChange}%</span>`:'') +
                     (it.deltaPx? `<span class="tag" style="background:${tagColor}">移動:${it.deltaPx}px</span>`:'') +
                     (it.iou? `<span class="tag" style="background:${tagColor}">IoU:${it.iou}%</span>`:'');
      ul.appendChild(li);
    });
  }
  fillList(els.listAdded,  items.addItems,  '#5bc0be');
  fillList(els.listRemoved,items.remItems,  '#ff9f43');
  fillList(els.listMoved,  items.moveItems, '#9b59b6');
}

/* === 描画（基準切替＋表現切替＋コメント作成） === */
function drawWithBase(base, renderMode, imgA, imgB, detA, detB, assignment){
  const baseImg   = (base==='A') ? imgA : imgB;
  const otherImg  = (base==='A') ? imgB : imgA;
  const baseDet   = (base==='A') ? detA : detB;
  const unmatchedAdded = (base==='A') ? assignment.unmatchedB : assignment.unmatchedA; // B側に追加 or A側に追加
  const unmatchedRemoved = (base==='A') ? assignment.unmatchedA : assignment.unmatchedB;

  const matches = assignment.matches;

  const ctx = els.canvas.getContext('2d');
  const MAX_W = parseInt(els.maxW.value,10);
  const ratio = Math.min(1, MAX_W / baseImg.naturalWidth);
  const W = Math.round(baseImg.naturalWidth * ratio);
  const H = Math.round(baseImg.naturalHeight * ratio);
  els.canvas.width = W; els.canvas.height = H;
  ctx.drawImage(baseImg, 0, 0, W, H);

  // 位置補正（AFFINE）
  let otherAlignedCanvas;
  if(els.chkAlign.checked){
    otherAlignedCanvas = alignOtherToBaseCanvasAffine(baseImg, otherImg, W, H);
  }else{
    otherAlignedCanvas = document.createElement('canvas'); otherAlignedCanvas.width=W; otherAlignedCanvas.height=H;
    otherAlignedCanvas.getContext('2d').drawImage(otherImg,0,0,W,H);
  }

  // マスク
  const mask = buildMaskFromDetections(W,H, baseDet, baseImg.naturalWidth, baseImg.naturalHeight);

  // 描画（boxes/heat）
  let hasChange=false;
  const sx = W / baseImg.naturalWidth, sy = H / baseImg.naturalHeight;

  if(renderMode==='boxes'){
    // 追加側の枠を重点表示
    let boxes = unmatchedAdded.map(d=>({...d}));
    const minAreaRatio = parseFloat(els.minArea.value)/100.0;
    const minAreaPx = minAreaRatio * (baseImg.naturalWidth * baseImg.naturalHeight);
    boxes = filterByArea(boxes, minAreaPx);
    boxes = nmsDiff(boxes, 0.35);
    boxes = topKByArea(boxes, parseInt(els.topK.value,10));
    hasChange = boxes.length>0;

    ctx.lineWidth = Math.max(3, Math.floor(W/512));
    const colStroke = (base==='A') ? 'rgba(64,128,255,0.98)' : 'rgba(255,160,64,0.98)';
    const colFill   = (base==='A') ? 'rgba(64,128,255,0.20)' : 'rgba(255,160,64,0.20)';
    ctx.strokeStyle=colStroke; ctx.fillStyle=colFill;

    boxes.forEach((b,idx)=>{
      const x=b.x1*sx, y=b.y1*sy, w=(b.x2-b.x1)*sx, h=(b.y2-b.y1)*sy;
      ctx.fillRect(x,y,w,h); ctx.strokeRect(x,y,w,h);
      drawNumberTag(ctx, x+Math.max(14,w*0.1), y+Math.max(14,h*0.1), idx+1, colStroke);
    });
  }else{
    hasChange = cvDiffHeatBetter(baseImg, otherAlignedCanvas, els.canvas, mask, parseInt(els.cvThr.value,10));
  }

  const label = (base==='A') ? 'Bに追加の差分' : 'Aに追加の差分';
  drawBadge(ctx, hasChange ? `あり：${label}` : 'なし：顕著な差分なし', hasChange);

  // コメント生成＆表示
  const items = makeCommentItems(base, W, H, unmatchedAdded, unmatchedRemoved, matches);
  const counts = { add:items.addItems.length, rem:items.remItems.length, mov:items.moveItems.length };
  renderCommentPanel(base, counts, items);

  // JSONエクスポート（コピー用）
  lastDiffJson = { base, counts, items };
  els.btnCopyJson.disabled = false;
}

/* === 推論ボタン === */
els.btnDetect.addEventListener('click', async ()=>{
  if(!aReady || !bReady){ alert('画像A・画像Bを選択（または撮影）してください'); return; }
  els.btnDetect.disabled = true; els.btnDetect.textContent = '推論中…';
  try{
    await ensureYolo();
    await waitForCv();

    const lbA = letterbox(els.imgA, 640);
    const lbB = letterbox(els.imgB, 640);
    const inputA = new ort.Tensor('float32', toCHWFloat32(lbA.canvas), [1,3,640,640]);
    const inputB = new ort.Tensor('float32', toCHWFloat32(lbB.canvas), [1,3,640,640]);

    const inName  = yoloSession.inputNames[0];
    const outName = yoloSession.outputNames[0];
    const feedsA = {}; feedsA[inName] = inputA;
    const feedsB = {}; feedsB[inName] = inputB;

    const confThr = parseFloat(els.confThr.value);
    const nmsIoU  = parseFloat(els.nmsThr.value);

    const outA = await yoloSession.run(feedsA);
    const outB = await yoloSession.run(feedsB);
    const tensorA = outA[outName] || Object.values(outA)[0];
    const tensorB = outB[outName] || Object.values(outB)[0];

    const detA = robustDecodeYOLOv8(tensorA, {ratio:lbA.ratio, padX:lbA.padX, padY:lbA.padY, origW:lbA.origW, origH:lbA.origH}, confThr, nmsIoU);
    const detB = robustDecodeYOLOv8(tensorB, {ratio:lbB.ratio, padX:lbB.padX, padY:lbB.padY, origW:lbB.origW, origH:lbB.origH}, confThr, nmsIoU);

    const assignment = greedyAssign(detA, detB, 0.45);
    const base = els.baseA.checked ? 'A' : 'B';
    const renderMode = els.modeHeat.checked ? 'heat' : 'boxes';
    drawWithBase(base, renderMode, els.imgA, els.imgB, detA, detB, assignment);

    els.btnSaveJpg.disabled = true;
    setTimeout(()=>{ els.btnSaveJpg.disabled = false; }, 120);
  }catch(e){
    console.error(e);
    alert(`推論/差分でエラー：${e.message}`);
  }finally{
    els.btnDetect.disabled = false; els.btnDetect.textContent = '差分を検出';
  }
});

/* === 保存・JSONコピー === */
els.btnSaveJpg.addEventListener('click', ()=>{
  const dataUrl = els.canvas.toDataURL('image/jpeg', 0.88);
  const a=document.createElement('a');
  a.href=dataUrl;
  a.download=`差分結果_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.jpg`;
  a.click();
});
els.btnCopyJson.addEventListener('click', ()=>{
  if(!lastDiffJson){ return; }
  navigator.clipboard.writeText(JSON.stringify(lastDiffJson, null, 2)).then(()=>{
    alert('差分JSONをクリップボードにコピーしました');
  }).catch(e=> alert('コピーに失敗しました：'+e.message));
});
</script>
</body>
</html>
``
